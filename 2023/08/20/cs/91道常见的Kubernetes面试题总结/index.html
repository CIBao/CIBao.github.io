<!-- build time:Mon Aug 21 2023 14:04:28 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="躺卷二重性" href="https://cibao.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="躺卷二重性" href="https://cibao.github.io/atom.xml"><link rel="alternate" type="application/json" title="躺卷二重性" href="https://cibao.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://cibao.github.io/2023/08/20/cs/91%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84Kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"><title>| CIBao = 躺卷二重性</title><meta name="generator" content="Hexo 6.1.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline"></h1><div class="meta"><span class="item" title="创建时间：2023-08-20 01:58:46"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-08-20T01:58:46+08:00">2023-08-20</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>31k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>28 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">CIBao</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipey84bjtj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicitf0kl1j20zk0m87fe.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciukx8a7j20zk0m8aio.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipevarprfj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipet8c1a2j20zk0m8kct.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciszlczyj20zk0m816d.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cibao.github.io/2023/08/20/cs/91%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84Kubernetes%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="CIBao"><meta itemprop="description" content=", 又菜又爱浪"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="躺卷二重性"></span><div class="body md" itemprop="articleBody"><h3 id="1-简述etcd及其特点"><a class="anchor" href="#1-简述etcd及其特点">#</a> 1、简述 etcd 及其特点</h3><p>etcd 是 CoreOS 团队发起的开源项目，是一个管理配置信息和服务发现（service discovery）的项目，它的目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。</p><p>特点：</p><ul><li>简单：支持 REST 风格的 HTTP+JSON API</li><li>安全：支持 HTTPS 方式的访问</li><li>快速：支持并发 1k/s 的写操作</li><li>可靠：支持分布式结构，基于 Raft 的一致性算法，Raft 是一套通过选举主节点来实现分布式系统一致性的算法。</li></ul><h3 id="2-简述etcd适应的场景"><a class="anchor" href="#2-简述etcd适应的场景">#</a> 2、简述 etcd 适应的场景</h3><p>etcd 基于其优秀的特点，可广泛的应用于以下场景：</p><ul><li>服务发现（Service Discovery）：服务发现主要解决在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听 UDP 或 TCP 端口，并且通过名字就可以查找和连接。</li><li>消息发布与订阅：在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。通过这种方式可以做到分布式系统配置的集中式管理与动态更新。应用中用到的一些配置信息放到 etcd 上进行集中管理。</li><li>负载均衡：在分布式系统中，为了保证服务的高可用以及数据的一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。etcd 本身分布式架构存储的信息访问支持负载均衡。etcd 集群化以后，每个 etcd 的核心节点都可以处理用户的请求。所以，把数据量小但是访问频繁的消息数据直接存储到 etcd 中也可以实现负载均衡的效果。</li><li>分布式通知与协调：与消息发布和订阅类似，都用到了 etcd 中的 Watcher 机制，通过注册与异步通知机制，实现分布式环境下不同系统之间的通知与协调，从而对数据变更做到实时处理。</li><li>分布式锁：因为 etcd 使用 Raft 算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。</li><li>集群监控与 Leader 竞选：通过 etcd 来进行监控实现起来非常简单并且实时性强。</li></ul><h3 id="3-简述什么是kubernetes"><a class="anchor" href="#3-简述什么是kubernetes">#</a> 3、简述什么是 Kubernetes</h3><p>Kubernetes 是一个全新的基于容器技术的分布式系统支撑平台。是 Google 开源的容器集群管理系统（谷歌内部：Borg）。在 Docker 技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。并且具有完备的集群管理能力，多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和发现机制、內建智能负载均衡器、强大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制以及多粒度的资源配额管理能力。</p><h3 id="4-简述kubernetes和docker的关系"><a class="anchor" href="#4-简述kubernetes和docker的关系">#</a> 4、简述 Kubernetes 和 Docker 的关系</h3><p>Docker 提供容器的生命周期管理和 Docker 镜像构建运行时容器。它的主要优点是将将软件 / 应用程序运行所需的设置和依赖项打包到一个容器中，从而实现了可移植性等优点。</p><p>Kubernetes 用于关联和编排在多个主机上运行的容器。</p><h3 id="5-简述minikube-kubectl-kubelet分别是什么"><a class="anchor" href="#5-简述minikube-kubectl-kubelet分别是什么">#</a> 5、简述 Minikube、Kubectl、Kubelet 分别是什么</h3><p>Minikube 是一种可以在本地轻松运行一个单节点 Kubernetes 群集的工具。</p><p>Kubectl 是一个命令行工具，可以使用该工具控制 Kubernetes 集群管理器，如检查群集资源，创建、删除和更新组件，查看应用程序。</p><p>Kubelet 是一个代理服务，它在每个节点上运行，并使从服务器与主服务器通信。</p><h3 id="6-简述kubernetes常见的部署方式"><a class="anchor" href="#6-简述kubernetes常见的部署方式">#</a> 6、简述 Kubernetes 常见的部署方式</h3><p>常见的 Kubernetes 部署方式有：</p><ul><li>kubeadm，也是推荐的一种部署方式；</li><li>二进制；</li><li>minikube，在本地轻松运行一个单节点 Kubernetes 群集的工具。</li></ul><h3 id="7-简述kubernetes如何实现集群管理"><a class="anchor" href="#7-简述kubernetes如何实现集群管理">#</a> 7、简述 Kubernetes 如何实现集群管理</h3><p>在集群管理方面，Kubernetes 将集群中的机器划分为一个 Master 节点和一群工作节点 Node。其中，在 Master 节点运行着集群管理相关的一组进程 kube-apiserver、kube-controller-manager 和 kube-scheduler，这些进程实现了整个集群的资源管理、Pod 调度、弹性伸缩、安全控制、系统监控和纠错等管理能力，并且都是全自动完成的。</p><h3 id="8-简述kubernetes的优势-适应场景及其特点"><a class="anchor" href="#8-简述kubernetes的优势-适应场景及其特点">#</a> 8、简述 Kubernetes 的优势、适应场景及其特点</h3><p>Kubernetes 作为一个完备的分布式系统支撑平台，其主要优势：</p><ul><li>容器编排</li><li>轻量级</li><li>开源</li><li>弹性伸缩</li><li>负载均衡</li></ul><p>Kubernetes 常见场景：</p><ul><li>快速部署应用</li><li>快速扩展应用</li><li>无缝对接新的应用功能</li><li>节省资源，优化硬件资源的使用</li></ul><p>Kubernetes 相关特点：</p><ul><li>可移植：支持公有云、私有云、混合云、多重云（multi-cloud）。</li><li>可扩展：模块化，、插件化、可挂载、可组合。</li><li>自动化：自动部署、自动重启、自动复制、自动伸缩 / 扩展。</li></ul><h3 id="9-简述kubernetes的缺点或当前的不足之处"><a class="anchor" href="#9-简述kubernetes的缺点或当前的不足之处">#</a> 9、简述 Kubernetes 的缺点或当前的不足之处</h3><p>Kubernetes 当前存在的缺点（不足）如下：</p><ul><li>安装过程和配置相对困难复杂。</li><li>管理服务相对繁琐。</li><li>运行和编译需要很多时间。</li><li>它比其他替代品更昂贵。</li><li>对于简单的应用程序来说，可能不需要涉及 Kubernetes 即可满足。</li></ul><h3 id="10-简述kubernetes相关基础概念"><a class="anchor" href="#10-简述kubernetes相关基础概念">#</a> 10、简述 Kubernetes 相关基础概念</h3><ul><li>Master：Kubernetes 集群的管理节点，负责管理集群，提供集群的资源数据访问入口。拥有 etcd 存储服务（可选），运行 Api Server 进程，Controller Manager 服务进程及 Scheduler 服务进程。</li><li>Node（worker）：Node（worker）是 Kubernetes 集群架构中运行 Pod 的服务节点，是 Kubernetes 集群操作的单元，用来承载被分配 Pod 的运行，是 Pod 运行的宿主机。运行 Docker Eninge 服务，守护进程 kunelet 及负载均衡器 kube-proxy。</li><li>Pod：运行于 Node 节点上，若干相关容器的组合。Pod 内包含的容器运行在同一宿主机上，使用相同的网络命名空间、IP 地址和端口，能够通过 localhost 进行通信。Pod 是 Kubernetes 进行创建、调度和管理的最小单位，它提供了比容器更高层次的抽象，使得部署和管理更加灵活。一个 Pod 可以包含一个容器或者多个相关容器。</li><li>Label：Kubernetes 中的 Label 实质是一系列的 Key/Value 键值对，其中 key 与 value 可自定义。Label 可以附加到各种资源对象上，如 Node、Pod、Service、RC 等。一个资源对象可以定义任意数量的 Label，同一个 Label 也可以被添加到任意数量的资源对象上去。Kubernetes 通过 Label Selector（标签选择器）查询和筛选资源对象。</li><li>Replication Controller：Replication Controller 用来管理 Pod 的副本，保证集群中存在指定数量的 Pod 副本。集群中副本的数量大于指定数量，则会停止指定数量之外的多余容器数量。反之，则会启动少于指定数量个数的容器，保证数量不变。Replication Controller 是实现弹性伸缩、动态扩容和滚动升级的核心。</li><li>Deployment：Deployment 在内部使用了 RS 来实现目的，Deployment 相当于 RC 的一次升级，其最大的特色为可以随时获知当前 Pod 的部署进度。</li><li>HPA（Horizontal Pod Autoscaler）：Pod 的横向自动扩容，也是 Kubernetes 的一种资源，通过追踪分析 RC 控制的所有 Pod 目标的负载变化情况，来确定是否需要针对性的调整 Pod 副本数量。</li><li>Service：Service 定义了 Pod 的逻辑集合和访问该集合的策略，是真实服务的抽象。Service 提供了一个统一的服务访问入口以及服务代理和发现机制，关联多个相同 Label 的 Pod，用户不需要了解后台 Pod 是如何运行。</li><li>Volume：Volume 是 Pod 中能够被多个容器访问的共享目录，Kubernetes 中的 Volume 是定义在 Pod 上，可以被一个或多个 Pod 中的容器挂载到某个目录下。</li><li>Namespace：Namespace 用于实现多租户的资源隔离，可将集群内部的资源对象分配到不同的 Namespace 中，形成逻辑上的不同项目、小组或用户组，便于不同的 Namespace 在共享使用整个集群的资源的同时还能被分别管理。</li></ul><h3 id="11-简述kubernetes集群相关组件"><a class="anchor" href="#11-简述kubernetes集群相关组件">#</a> 11、简述 Kubernetes 集群相关组件</h3><p>Kubernetes Master 控制组件，调度管理整个系统（集群），包含如下组件：</p><ul><li>Kubernetes API Server：作为 Kubernetes 系统的入口，其封装了核心对象的增删改查操作，以 RESTful API 接口方式提供给外部客户和内部组件调用，集群内各个功能模块之间数据交互和通信的中心枢纽。</li><li>Kubernetes Scheduler：为新建立的 Pod 进行节点（Node）选择（即分配机器），负责集群的资源调度。</li><li>Kubernetes Controller：负责执行各种控制器，目前已经提供了很多控制器来保证 Kubernetes 的正常运行。</li><li>Replication Controller：管理维护 Replication Controller，关联 Replication Controller 和 Pod，保证 Replication Controller 定义的副本数量与实际运行 Pod 数量一致。</li><li>Node Controller：管理维护 Node，定期检查 Node 的健康状态，标识出（失效 | 未失效）的 Node 节点。</li><li>Namespace Controller：管理维护 Namespace，定期清理无效的 Namespace，包括 Namesapce 下的 API 对象，比如 Pod、Service 等。</li><li>Service Controller：管理维护 Service，提供负载以及服务代理。</li><li>EndPoints Controller：管理维护 Endpoints，关联 Service 和 Pod，创建 Endpoints 为 Service 的后端，当 Pod 发生变化时，实时更新 Endpoints。</li><li>Service Account Controller：管理维护 Service Account，为每个 Namespace 创建默认的 Service Account，同时为 Service Account 创建 Service Account Secret。</li><li>Persistent Volume Controller：管理维护 Persistent Volume 和 Persistent Volume Claim，为新的 Persistent Volume Claim 分配 Persistent Volume 进行绑定，为释放的 Persistent Volume 执行清理回收。</li><li>Daemon Set Controller：管理维护 Daemon Set，负责创建 Daemon Pod，保证指定的 Node 上正常的运行 Daemon Pod。</li><li>Deployment Controller：管理维护 Deployment，关联 Deployment 和 Replication Controller，保证运行指定数量的 Pod。当 Deployment 更新时，控制实现 Replication Controller 和 Pod 的更新。</li><li>Job Controller：管理维护 Job，为 Jod 创建一次性任务 Pod，保证完成 Job 指定完成的任务数目</li><li>Pod Autoscaler Controller：实现 Pod 的自动伸缩，定时获取监控数据，进行策略匹配，当满足条件时执行 Pod 的伸缩动作。</li></ul><h3 id="12-简述kubernetes-rc的机制"><a class="anchor" href="#12-简述kubernetes-rc的机制">#</a> 12、简述 Kubernetes RC 的机制</h3><p>Replication Controller 用来管理 Pod 的副本，保证集群中存在指定数量的 Pod 副本。当定义了 RC 并提交至 Kubernetes 集群中之后，Master 节点上的 Controller Manager 组件获悉，并同时巡检系统中当前存活的目标 Pod，并确保目标 Pod 实例的数量刚好等于此 RC 的期望值，若存在过多的 Pod 副本在运行，系统会停止一些 Pod，反之则自动创建一些 Pod。</p><h3 id="13-简述kubernetes-replica-set和replication-controller之间有什么区别"><a class="anchor" href="#13-简述kubernetes-replica-set和replication-controller之间有什么区别">#</a> 13、简述 Kubernetes Replica Set 和 Replication Controller 之间有什么区别</h3><p>Replica Set 和 Replication Controller 类似，都是确保在任何给定时间运行指定数量的 Pod 副本。不同之处在于 RS 使用基于集合的选择器，而 Replication Controller 使用基于权限的选择器。</p><h3 id="14-简述kube-proxy的作用"><a class="anchor" href="#14-简述kube-proxy的作用">#</a> 14、简述 kube-proxy 的作用</h3><p>kube-proxy 运行在所有节点上，它监听 apiserver 中 service 和 endpoint 的变化情况，创建路由规则以提供服务 IP 和负载均衡功能。简单理解此进程是 Service 的透明代理兼负载均衡器，其核心功能是将到某个 Service 的访问请求转发到后端的多个 Pod 实例上。</p><h3 id="15-简述kube-proxy-iptables的原理"><a class="anchor" href="#15-简述kube-proxy-iptables的原理">#</a> 15、简述 kube-proxy iptables 的原理</h3><p>Kubernetes 从 1.2 版本开始，将 iptables 作为 kube-proxy 的默认模式。iptables 模式下的 kube-proxy 不再起到 Proxy 的作用，其核心功能：通过 API Server 的 Watch 接口实时跟踪 Service 与 Endpoint 的变更信息，并更新对应的 iptables 规则，Client 的请求流量则通过 iptables 的 NAT 机制 “直接路由” 到目标 Pod。</p><h3 id="16-简述kube-proxy-ipvs的原理"><a class="anchor" href="#16-简述kube-proxy-ipvs的原理">#</a> 16、简述 kube-proxy ipvs 的原理</h3><p>IPVS 在 Kubernetes1.11 中升级为 GA 稳定版。IPVS 则专门用于高性能负载均衡，并使用更高效的数据结构（Hash 表），允许几乎无限的规模扩张，因此被 kube-proxy 采纳为最新模式。</p><p>在 IPVS 模式下，使用 iptables 的扩展 ipset，而不是直接调用 iptables 来生成规则链。iptables 规则链是一个线性的数据结构，ipset 则引入了带索引的数据结构，因此当规则很多时，也可以很高效地查找和匹配。</p><p>可以将 ipset 简单理解为一个 IP（段）的集合，这个集合的内容可以是 IP 地址、IP 网段、端口等，iptables 可以直接添加规则对这个 “可变的集合” 进行操作，这样做的好处在于可以大大减少 iptables 规则的数量，从而减少性能损耗。</p><h3 id="17-简述kube-proxy-ipvs和iptables的异同"><a class="anchor" href="#17-简述kube-proxy-ipvs和iptables的异同">#</a> 17、简述 kube-proxy ipvs 和 iptables 的异同</h3><p>iptables 与 IPVS 都是基于 Netfilter 实现的，但因为定位不同，二者有着本质的差别：iptables 是为防火墙而设计的；IPVS 则专门用于高性能负载均衡，并使用更高效的数据结构（Hash 表），允许几乎无限的规模扩张。</p><p>与 iptables 相比，IPVS 拥有以下明显优势：</p><ul><li>为大型集群提供了更好的可扩展性和性能；</li><li>支持比 iptables 更复杂的复制均衡算法（最小负载、最少连接、加权等）；</li><li>支持服务器健康检查和连接重试等功能；</li><li>可以动态修改 ipset 的集合，即使 iptables 的规则正在使用这个集合。</li></ul><h3 id="18-简述kubernetes中什么是静态pod"><a class="anchor" href="#18-简述kubernetes中什么是静态pod">#</a> 18、简述 Kubernetes 中什么是静态 Pod</h3><p>静态 Pod 是由 kubelet 进行管理的仅存在于特定 Node 的 Pod 上，他们不能通过 API Server 进行管理，无法与 ReplicationController、Deployment 或者 DaemonSet 进行关联，并且 kubelet 无法对他们进行健康检查。静态 Pod 总是由 kubelet 进行创建，并且总是在 kubelet 所在的 Node 上运行。</p><h3 id="19-简述kubernetes中pod可能位于的状态"><a class="anchor" href="#19-简述kubernetes中pod可能位于的状态">#</a> 19、简述 Kubernetes 中 Pod 可能位于的状态</h3><ul><li>Pending：API Server 已经创建该 Pod，且 Pod 内还有一个或多个容器的镜像没有创建，包括正在下载镜像的过程。</li><li>Running：Pod 内所有容器均已创建，且至少有一个容器处于运行状态、正在启动状态或正在重启状态。</li><li>Succeeded：Pod 内所有容器均成功执行退出，且不会重启。</li><li>Failed：Pod 内所有容器均已退出，但至少有一个容器退出为失败状态。</li><li>Unknown：由于某种原因无法获取该 Pod 状态，可能由于网络通信不畅导致。</li></ul><h3 id="20-简述kubernetes创建一个pod的主要流程"><a class="anchor" href="#20-简述kubernetes创建一个pod的主要流程">#</a> 20、简述 Kubernetes 创建一个 Pod 的主要流程？</h3><p>Kubernetes 中创建一个 Pod 涉及多个组件之间联动，主要流程如下：</p><ul><li>客户端提交 Pod 的配置信息（可以是 yaml 文件定义的信息）到 kube-apiserver。</li><li>Apiserver 收到指令后，通知给 controller-manager 创建一个资源对象。</li><li>Controller-manager 通过 api-server 将 Pod 的配置信息存储到 etcd 数据中心中。</li><li>Kube-scheduler 检测到 Pod 信息会开始调度预选，会先过滤掉不符合 Pod 资源配置要求的节点，然后开始调度调优，主要是挑选出更适合运行 Pod 的节点，然后将 Pod 的资源配置单发送到 Node 节点上的 kubelet 组件上。</li><li>Kubelet 根据 scheduler 发来的资源配置单运行 Pod，运行成功后，将 Pod 的运行信息返回给 scheduler，scheduler 将返回的 Pod 运行状况的信息存储到 etcd 数据中心。</li></ul><h3 id="21-简述kubernetes中pod的重启策略"><a class="anchor" href="#21-简述kubernetes中pod的重启策略">#</a> 21、简述 Kubernetes 中 Pod 的重启策略</h3><p>Pod 重启策略（RestartPolicy）应用于 Pod 内的所有容器，并且仅在 Pod 所处的 Node 上由 kubelet 进行判断和重启操作。当某个容器异常退出或者健康检查失败时，kubelet 将根据 RestartPolicy 的设置来进行相应操作。</p><p>Pod 的重启策略包括 Always、OnFailure 和 Never，默认值为 Always。</p><ul><li>Always：当容器失效时，由 kubelet 自动重启该容器；</li><li>OnFailure：当容器终止运行且退出码不为 0 时，由 kubelet 自动重启该容器；</li><li>Never：不论容器运行状态如何，kubelet 都不会重启该容器。</li></ul><p>同时 Pod 的重启策略与控制方式关联，当前可用于管理 Pod 的控制器包括 ReplicationController、Job、DaemonSet 及直接管理 kubelet 管理（静态 Pod）。</p><p>不同控制器的重启策略限制如下：</p><ul><li>RC 和 DaemonSet：必须设置为 Always，需要保证该容器持续运行；</li><li>Job：OnFailure 或 Never，确保容器执行完成后不再重启；</li><li>kubelet：在 Pod 失效时重启，不论将 RestartPolicy 设置为何值，也不会对 Pod 进行健康检查。</li></ul><h3 id="22-简述kubernetes中pod的健康检查方式"><a class="anchor" href="#22-简述kubernetes中pod的健康检查方式">#</a> 22、简述 Kubernetes 中 Pod 的健康检查方式</h3><p>对 Pod 的健康检查可以通过两类探针来检查：LivenessProbe 和 ReadinessProbe。</p><ul><li>LivenessProbe 探针：用于判断容器是否存活（running 状态），如果 LivenessProbe 探针探测到容器不健康，则 kubelet 将杀掉该容器，并根据容器的重启策略做相应处理。若一个容器不包含 LivenessProbe 探针，kubelet 认为该容器的 LivenessProbe 探针返回值用于是 “Success”。</li><li>ReadineeProbe 探针：用于判断容器是否启动完成（ready 状态）。如果 ReadinessProbe 探针探测到失败，则 Pod 的状态将被修改。Endpoint Controller 将从 Service 的 Endpoint 中删除包含该容器所在 Pod 的 Eenpoint。</li><li>startupProbe 探针：启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针 kill 掉。</li></ul><h3 id="23-简述kubernetes-pod的livenessprobe探针的常见方式"><a class="anchor" href="#23-简述kubernetes-pod的livenessprobe探针的常见方式">#</a> 23、简述 Kubernetes Pod 的 LivenessProbe 探针的常见方式</h3><p>kubelet 定期执行 LivenessProbe 探针来诊断容器的健康状态，通常有以下三种方式：</p><ul><li>ExecAction：在容器内执行一个命令，若返回码为 0，则表明容器健康。</li><li>TCPSocketAction：通过容器的 IP 地址和端口号执行 TCP 检查，若能建立 TCP 连接，则表明容器健康。</li><li>HTTPGetAction：通过容器的 IP 地址、端口号及路径调用 HTTP Get 方法，若响应的状态码大于等于 200 且小于 400，则表明容器健康。</li></ul><h3 id="24-简述kubernetes-pod的常见调度方式"><a class="anchor" href="#24-简述kubernetes-pod的常见调度方式">#</a> 24、简述 Kubernetes Pod 的常见调度方式</h3><p>Kubernetes 中，Pod 通常是容器的载体，主要有如下常见调度方式：</p><ul><li>Deployment 或 RC：该调度策略主要功能就是自动部署一个容器应用的多份副本，以及持续监控副本的数量，在集群内始终维持用户指定的副本数量。</li><li>NodeSelector：定向调度，当需要手动指定将 Pod 调度到特定 Node 上，可以通过 Node 的标签（Label）和 Pod 的 nodeSelector 属性相匹配。</li><li>NodeAffinity 亲和性调度：亲和性调度机制极大的扩展了 Pod 的调度能力，目前有两种节点亲和力表达：<ul><li>requiredDuringSchedulingIgnoredDuringExecution：硬规则，必须满足指定的规则，调度器才可以调度 Pod 至 Node 上（类似 nodeSelector，语法不同）。</li><li>preferredDuringSchedulingIgnoredDuringExecution：软规则，优先调度至满足的 Node 的节点，但不强求，多个优先级规则还可以设置权重值。</li></ul></li><li>Taints 和 Tolerations（污点和容忍）：<ul><li>Taint：使 Node 拒绝特定 Pod 运行；</li><li>Toleration：为 Pod 的属性，表示 Pod 能容忍（运行）标注了 Taint 的 Node。</li></ul></li></ul><h3 id="25-简述kubernetes初始化容器init-container"><a class="anchor" href="#25-简述kubernetes初始化容器init-container">#</a> 25、简述 Kubernetes 初始化容器（init container）</h3><p>init container 的运行方式与应用容器不同，它们必须先于应用容器执行完成，当设置了多个 init container 时，将按顺序逐个运行，并且只有前一个 init container 运行成功后才能运行后一个 init container。当所有 init container 都成功运行后，Kubernetes 才会初始化 Pod 的各种信息，并开始创建和运行应用容器。</p><h3 id="26-简述kubernetes-deployment升级过程"><a class="anchor" href="#26-简述kubernetes-deployment升级过程">#</a> 26、简述 Kubernetes deployment 升级过程</h3><ul><li>初始创建 Deployment 时，系统创建了一个 ReplicaSet，并按用户的需求创建了对应数量的 Pod 副本。</li><li>当更新 Deployment 时，系统创建了一个新的 ReplicaSet，并将其副本数量扩展到 1，然后将旧 ReplicaSet 缩减为 2。</li><li>之后，系统继续按照相同的更新策略对新旧两个 ReplicaSet 进行逐个调整。</li><li>最后，新的 ReplicaSet 运行了对应个新版本 Pod 副本，旧的 ReplicaSet 副本数量则缩减为 0。</li></ul><h3 id="27-简述kubernetes-deployment升级策略"><a class="anchor" href="#27-简述kubernetes-deployment升级策略">#</a> 27、简述 Kubernetes deployment 升级策略</h3><p>在 Deployment 的定义中，可以通过 spec.strategy 指定 Pod 更新的策略，目前支持两种策略：Recreate（重建）和 RollingUpdate（滚动更新），默认值为 RollingUpdate。</p><ul><li>Recreate：设置 spec.strategy.type=Recreate，表示 Deployment 在更新 Pod 时，会先杀掉所有正在运行的 Pod，然后创建新的 Pod。</li><li>RollingUpdate：设置 spec.strategy.type=RollingUpdate，表示 Deployment 会以滚动更新的方式来逐个更新 Pod。同时，可以通过设置 spec.strategy.rollingUpdate 下的两个参数（maxUnavailable 和 maxSurge）来控制滚动更新的过程。</li></ul><h3 id="28-简述kubernetes-daemonset类型的资源特性"><a class="anchor" href="#28-简述kubernetes-daemonset类型的资源特性">#</a> 28、简述 Kubernetes DaemonSet 类型的资源特性</h3><p>DaemonSet 资源对象会在每个 Kubernetes 集群中的节点上运行，并且每个节点只能运行一个 Pod，这是它和 Deployment 资源对象的最大也是唯一的区别。因此，在定义 yaml 文件中，不支持定义 replicas。</p><p>它的一般使用场景如下：</p><ul><li>在去做每个节点的日志收集工作。</li><li>监控每个节点的的运行状态。</li></ul><h3 id="29-简述kubernetes自动扩容机制"><a class="anchor" href="#29-简述kubernetes自动扩容机制">#</a> 29、简述 Kubernetes 自动扩容机制</h3><p>Kubernetes 使用 Horizontal Pod Autoscaler（HPA）的控制器实现基于 CPU 使用率进行自动 Pod 扩缩容的功能。HPA 控制器周期性地监测目标 Pod 的资源性能指标，并与 HPA 资源对象中的扩缩容条件进行对比，在满足条件时对 Pod 副本数量进行调整。</p><p>Kubernetes 中的某个 Metrics Server（Heapster 或自定义 Metrics Server）持续采集所有 Pod 副本的指标数据。HPA 控制器通过 Metrics Server 的 API（Heapster 的 API 或聚合 API）获取这些数据，基于用户定义的扩缩容规则进行计算，得到目标 Pod 副本数量。</p><p>当目标 Pod 副本数量与当前副本数量不同时，HPA 控制器就向 Pod 的副本控制器（Deployment、RC 或 ReplicaSet）发起 scale 操作，调整 Pod 的副本数量，完成扩缩容操作。</p><h3 id="30-简述kubernetes-service类型"><a class="anchor" href="#30-简述kubernetes-service类型">#</a> 30、简述 Kubernetes Service 类型</h3><p>通过创建 Service，可以为一组具有相同功能的容器应用提供一个统一的入口地址，并且将请求负载分发到后端的各个容器应用上。其主要类型有：</p><ul><li>ClusterIP：虚拟的服务 IP 地址，该地址用于 Kubernetes 集群内部的 Pod 访问，在 Node 上 kube-proxy 通过设置的 iptables 规则进行转发；</li><li>NodePort：使用宿主机的端口，使能够访问各 Node 的外部客户端通过 Node 的 IP 地址和端口号就能访问服务；</li><li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，需要在 spec.status.loadBalancer 字段指定外部负载均衡器的 IP 地址，通常用于公有云。</li></ul><h3 id="31-简述kubernetes-service分发后端的策略"><a class="anchor" href="#31-简述kubernetes-service分发后端的策略">#</a> 31、简述 Kubernetes Service 分发后端的策略</h3><p>Service 负载分发的策略有：RoundRobin 和 SessionAffinity</p><ul><li>RoundRobin：默认为轮询模式，即轮询将请求转发到后端的各个 Pod 上。</li><li>SessionAffinity：基于客户端 IP 地址进行会话保持的模式，即第 1 次将某个客户端发起的请求转发到后端的某个 Pod 上，之后从相同的客户端发起的请求都将被转发到后端相同的 Pod 上。</li></ul><h3 id="32-简述kubernetes-headless-service"><a class="anchor" href="#32-简述kubernetes-headless-service">#</a> 32、简述 Kubernetes Headless Service</h3><p>在某些应用场景中，若需要人为指定负载均衡器，不使用 Service 提供的默认负载均衡的功能，或者应用程序希望知道属于同组服务的其他实例。Kubernetes 提供了 Headless Service 来实现这种功能，即不为 Service 设置 ClusterIP（入口 IP 地址），仅通过 Label Selector 将后端的 Pod 列表返回给调用的客户端。</p><h3 id="33-简述kubernetes外部如何访问集群内的服务"><a class="anchor" href="#33-简述kubernetes外部如何访问集群内的服务">#</a> 33、简述 Kubernetes 外部如何访问集群内的服务</h3><p>对于 Kubernetes，集群外的客户端默认情况，无法通过 Pod 的 IP 地址或者 Service 的虚拟 IP 地址：虚拟端口号进行访问。通常可以通过以下方式进行访问 Kubernetes 集群内的服务：</p><ul><li>映射 Pod 到物理机：将 Pod 端口号映射到宿主机，即在 Pod 中采用 hostPort 方式，以使客户端应用能够通过物理机访问容器应用。</li><li>映射 Service 到物理机：将 Service 端口号映射到宿主机，即在 Service 中采用 nodePort 方式，以使客户端应用能够通过物理机访问容器应用。</li><li>映射 Sercie 到 LoadBalancer：通过设置 LoadBalancer 映射到云服务商提供的 LoadBalancer 地址。这种用法仅用于在公有云服务提供商的云平台上设置 Service 的场景。</li></ul><h3 id="34-简述kubernetes-ingress"><a class="anchor" href="#34-简述kubernetes-ingress">#</a> 34、简述 Kubernetes ingress</h3><p>Kubernetes 的 Ingress 资源对象，用于将不同 URL 的访问请求转发到后端不同的 Service，以实现 HTTP 层的业务路由机制。</p><p>Kubernetes 使用了 Ingress 策略和 Ingress Controller，两者结合并实现了一个完整的 Ingress 负载均衡器。使用 Ingress 进行负载分发时，Ingress Controller 基于 Ingress 规则将客户端请求直接转发到 Service 对应的后端 Endpoint（Pod）上，从而跳过 kube-proxy 的转发功能，kube-proxy 不再起作用，全过程为：ingress controller + ingress 规则 ----&gt; services。</p><p>同时当 Ingress Controller 提供的是对外服务，则实际上实现的是边缘路由器的功能。</p><h3 id="35-简述kubernetes镜像的下载策略"><a class="anchor" href="#35-简述kubernetes镜像的下载策略">#</a> 35、简述 Kubernetes 镜像的下载策略</h3><p>Kubernetes 的镜像下载策略有三种：Always、Never、IFNotPresent。</p><ul><li>Always：镜像标签为 latest 时，总是从指定的仓库中获取镜像。</li><li>Never：禁止从仓库中下载镜像，也就是说只能使用本地镜像。</li><li>IfNotPresent：仅当本地没有对应镜像时，才从目标仓库中下载。默认的镜像下载策略是：当镜像标签是 latest 时，默认策略是 Always；当镜像标签是自定义时（也就是标签不是 latest），那么默认策略是 IfNotPresent。</li></ul><h3 id="36-简述kubernetes的负载均衡器"><a class="anchor" href="#36-简述kubernetes的负载均衡器">#</a> 36、简述 Kubernetes 的负载均衡器</h3><p>负载均衡器是暴露服务的最常见和标准方式之一。</p><p>根据工作环境使用两种类型的负载均衡器，即内部负载均衡器或外部负载均衡器。内部负载均衡器自动平衡负载并使用所需配置分配容器，而外部负载均衡器将流量从外部负载引导至后端容器。</p><h3 id="37-简述kubernetes各模块如何与api-server通信"><a class="anchor" href="#37-简述kubernetes各模块如何与api-server通信">#</a> 37、简述 Kubernetes 各模块如何与 API Server 通信</h3><p>Kubernetes API Server 作为集群的核心，负责集群各功能模块之间的通信。集群内的各个功能模块通过 API Server 将信息存入 etcd，当需要获取和操作这些数据时，则通过 API Server 提供的 REST 接口（用 GET、LIST 或 WATCH 方法）来实现，从而实现各模块之间的信息交互。</p><p>如 kubelet 进程与 API Server 的交互：每个 Node 上的 kubelet 每隔一个时间周期，就会调用一次 API Server 的 REST 接口报告自身状态，API Server 在接收到这些信息后，会将节点状态信息更新到 etcd 中。</p><p>如 kube-controller-manager 进程与 API Server 的交互：kube-controller-manager 中的 Node Controller 模块通过 API Server 提供的 Watch 接口实时监控 Node 的信息，并做相应处理。</p><p>如 kube-scheduler 进程与 API Server 的交互：Scheduler 通过 API Server 的 Watch 接口监听到新建 Pod 副本的信息后，会检索所有符合该 Pod 要求的 Node 列表，开始执行 Pod 调度逻辑，在调度成功后将 Pod 绑定到目标节点上。</p><h3 id="38-简述kubernetes-scheduler作用及实现原理"><a class="anchor" href="#38-简述kubernetes-scheduler作用及实现原理">#</a> 38、简述 Kubernetes Scheduler 作用及实现原理</h3><p>Kubernetes Scheduler 是负责 Pod 调度的重要功能模块，Kubernetes Scheduler 在整个系统中承担了 “承上启下” 的重要功能，“承上” 是指它负责接收 Controller Manager 创建的新 Pod，为其调度至目标 Node；“启下” 是指调度完成后，目标 Node 上的 kubelet 服务进程接管后继工作，负责 Pod 接下来生命周期。</p><p>Kubernetes Scheduler 的作用是将待调度的 Pod（API 新创建的 Pod、Controller Manager 为补足副本而创建的 Pod 等）按照特定的调度算法和调度策略绑定（Binding）到集群中某个合适的 Node 上，并将绑定信息写入 etcd 中。</p><p>在整个调度过程中涉及三个对象，分别是待调度 Pod 列表、可用 Node 列表，以及调度算法和策略。</p><p>Kubernetes Scheduler 通过调度算法调度为待调度 Pod 列表中的每个 Pod 从 Node 列表中选择一个最适合的 Node 来实现 Pod 的调度。随后，目标节点上的 kubelet 通过 API Server 监听到 Kubernetes Scheduler 产生的 Pod 绑定事件，然后获取对应的 Pod 清单，下载 Image 镜像并启动容器。</p><h3 id="39-简述kubernetes-scheduler使用哪两种算法将pod绑定到worker节点"><a class="anchor" href="#39-简述kubernetes-scheduler使用哪两种算法将pod绑定到worker节点">#</a> 39、简述 Kubernetes Scheduler 使用哪两种算法将 Pod 绑定到 worker 节点</h3><p>Kubernetes Scheduler 根据如下两种调度算法将 Pod 绑定到最合适的工作节点：</p><ul><li>预选（Predicates）：输入是所有节点，输出是满足预选条件的节点。kube-scheduler 根据预选策略过滤掉不满足策略的 Nodes。如果某节点的资源不足或者不满足预选策略的条件则无法通过预选。如 “Node 的 label 必须与 Pod 的 Selector 一致”。</li><li>优选（Priorities）：输入是预选阶段筛选出的节点，优选会根据优先策略为通过预选的 Nodes 进行打分排名，选择得分最高的 Node。例如，资源越富裕、负载越小的 Node 可能具有越高的排名。</li></ul><h3 id="40-简述kubernetes-kubelet的作用"><a class="anchor" href="#40-简述kubernetes-kubelet的作用">#</a> 40、简述 Kubernetes kubelet 的作用</h3><p>在 Kubernetes 集群中，在每个 Node（又称 Worker）上都会启动一个 kubelet 服务进程。该进程用于处理 Master 下发到本节点的任务，管理 Pod 及 Pod 中的容器。每个 kubelet 进程都会在 API Server 上注册节点自身的信息，定期向 Master 汇报节点资源的使用情况，并通过 cAdvisor 监控容器和节点资源。</p><h3 id="41-简述kubernetes-kubelet监控worker节点资源是使用什么组件来实现的"><a class="anchor" href="#41-简述kubernetes-kubelet监控worker节点资源是使用什么组件来实现的">#</a> 41、简述 Kubernetes kubelet 监控 Worker 节点资源是使用什么组件来实现的</h3><p>kubelet 使用 cAdvisor 对 worker 节点资源进行监控。在 Kubernetes 系统中，cAdvisor 已被默认集成到 kubelet 组件内，当 kubelet 服务启动时，它会自动启动 cAdvisor 服务，然后 cAdvisor 会实时采集所在节点的性能指标及在节点上运行的容器的性能指标。</p><h3 id="42-简述kubernetes如何保证集群的安全性"><a class="anchor" href="#42-简述kubernetes如何保证集群的安全性">#</a> 42、简述 Kubernetes 如何保证集群的安全性</h3><p>Kubernetes 通过一系列机制来实现集群的安全控制，主要有如下不同的维度：</p><ul><li>基础设施方面：保证容器与其所在宿主机的隔离；</li><li>权限方面：<ul><li>最小权限原则：合理限制所有组件的权限，确保组件只执行它被授权的行为，通过限制单个组件的能力来限制它的权限范围。</li><li>用户权限：划分普通用户和管理员的角色。</li></ul></li><li>集群方面：<ul><li>API Server 的认证授权：Kubernetes 集群中所有资源的访问和变更都是通过 Kubernetes API Server 来实现的，因此需要建议采用更安全的 HTTPS 或 Token 来识别和认证客户端身份（Authentication），以及随后访问权限的授权（Authorization）环节。</li><li>API Server 的授权管理：通过授权策略来决定一个 API 调用是否合法。对合法用户进行授权并且随后在用户访问时进行鉴权，建议采用更安全的 RBAC 方式来提升集群安全授权。</li></ul></li><li>敏感数据引入 Secret 机制：对于集群敏感数据建议使用 Secret 方式进行保护。</li><li>AdmissionControl（准入机制）：对 kubernetes api 的请求过程中，顺序为：先经过认证 &amp; 授权，然后执行准入操作，最后对目标对象进行操作。</li></ul><h3 id="43-简述kubernetes准入机制"><a class="anchor" href="#43-简述kubernetes准入机制">#</a> 43、简述 Kubernetes 准入机制</h3><p>在对集群进行请求时，每个准入控制代码都按照一定顺序执行。如果有一个准入控制拒绝了此次请求，那么整个请求的结果将会立即返回，并提示用户相应的 error 信息。</p><p>准入控制（AdmissionControl）准入控制本质上为一段准入代码，在对 kubernetes api 的请求过程中，顺序为：先经过认证 &amp; 授权，然后执行准入操作，最后对目标对象进行操作。常用组件（控制代码）如下：</p><ul><li>AlwaysAdmit：允许所有请求</li><li>AlwaysDeny：禁止所有请求，多用于测试环境。</li><li>ServiceAccount：它将 serviceAccounts 实现了自动化，它会辅助 serviceAccount 做一些事情，比如如果 pod 没有 serviceAccount 属性，它会自动添加一个 default，并确保 pod 的 serviceAccount 始终存在。</li><li>LimitRanger：观察所有的请求，确保没有违反已经定义好的约束条件，这些条件定义在 namespace 中 LimitRange 对象中。</li><li>NamespaceExists：观察所有的请求，如果请求尝试创建一个不存在的 namespace，则这个请求被拒绝。</li></ul><h3 id="44-简述kubernetes-rbac及其特点优势"><a class="anchor" href="#44-简述kubernetes-rbac及其特点优势">#</a> 44、简述 Kubernetes RBAC 及其特点（优势）</h3><p>RBAC 是基于角色的访问控制，是一种基于个人用户的角色来管理对计算机或网络资源的访问的方法。</p><p>相对于其他授权模式，RBAC 具有如下优势：</p><ul><li>对集群中的资源和非资源权限均有完整的覆盖。</li><li>整个 RBAC 完全由几个 API 对象完成， 同其他 API 对象一样， 可以用 kubectl 或 API 进行操作。</li><li>可以在运行时进行调整，无须重新启动 API Server。</li></ul><h3 id="45-简述kubernetes-secret作用"><a class="anchor" href="#45-简述kubernetes-secret作用">#</a> 45、简述 Kubernetes Secret 作用</h3><p>Secret 对象，主要作用是保管私密数据，比如密码、OAuth Tokens、SSH Keys 等信息。将这些私密信息放在 Secret 对象中比直接放在 Pod 或 Docker Image 中更安全，也更便于使用和分发。</p><h3 id="46-简述kubernetes-secret有哪些使用方式"><a class="anchor" href="#46-简述kubernetes-secret有哪些使用方式">#</a> 46、简述 Kubernetes Secret 有哪些使用方式</h3><p>创建完 secret 之后，可通过如下三种方式使用：</p><ul><li>在创建 Pod 时，通过为 Pod 指定 Service Account 来自动使用该 Secret。</li><li>通过挂载该 Secret 到 Pod 来使用它。</li><li>在 Docker 镜像下载时使用，通过指定 Pod 的 spc.ImagePullSecrets 来引用它。</li></ul><h3 id="47-简述kubernetes-podsecuritypolicy机制"><a class="anchor" href="#47-简述kubernetes-podsecuritypolicy机制">#</a> 47、简述 Kubernetes PodSecurityPolicy 机制</h3><p>Kubernetes PodSecurityPolicy 是为了更精细地控制 Pod 对资源的使用方式以及提升安全策略。在开启 PodSecurityPolicy 准入控制器后，Kubernetes 默认不允许创建任何 Pod，需要创建 PodSecurityPolicy 策略和相应的 RBAC 授权策略（Authorizing Policies），Pod 才能创建成功。</p><h3 id="48-简述kubernetes-podsecuritypolicy机制能实现哪些安全策略"><a class="anchor" href="#48-简述kubernetes-podsecuritypolicy机制能实现哪些安全策略">#</a> 48、简述 Kubernetes PodSecurityPolicy 机制能实现哪些安全策略</h3><p>在 PodSecurityPolicy 对象中可以设置不同字段来控制 Pod 运行时的各种安全策略，常见的有：</p><ul><li>特权模式：privileged 是否允许 Pod 以特权模式运行。</li><li>宿主机资源：控制 Pod 对宿主机资源的控制，如 hostPID：是否允许 Pod 共享宿主机的进程空间。</li><li>用户和组：设置运行容器的用户 ID（范围）或组（范围）。</li><li>提升权限：AllowPrivilegeEscalation：设置容器内的子进程是否可以提升权限，通常在设置非 root 用户（MustRunAsNonRoot）时进行设置。</li><li>SELinux：进行 SELinux 的相关配置。</li></ul><h3 id="49-简述kubernetes网络模型"><a class="anchor" href="#49-简述kubernetes网络模型">#</a> 49、简述 Kubernetes 网络模型</h3><p>Kubernetes 网络模型中每个 Pod 都拥有一个独立的 IP 地址，并假定所有 Pod 都在一个可以直接连通的、扁平的网络空间中。所以不管它们是否运行在同一个 Node（宿主机）中，都要求它们可以直接通过对方的 IP 进行访问。设计这个原则的原因是，用户不需要额外考虑如何建立 Pod 之间的连接，也不需要考虑如何将容器端口映射到主机端口等问题。</p><p>同时为每个 Pod 都设置一个 IP 地址的模型使得同一个 Pod 内的不同容器会共享同一个网络命名空间，也就是同一个 Linux 网络协议栈。这就意味着同一个 Pod 内的容器可以通过 localhost 来连接对方的端口。</p><p>在 Kubernetes 的集群里，IP 是以 Pod 为单位进行分配的。一个 Pod 内部的所有容器共享一个网络堆栈（相当于一个网络命名空间，它们的 IP 地址、网络设备、配置等都是共享的）。</p><h3 id="50-简述kubernetes-cni模型"><a class="anchor" href="#50-简述kubernetes-cni模型">#</a> 50、简述 Kubernetes CNI 模型</h3><p>CNI 提供了一种应用容器的插件化网络解决方案，定义对容器网络进行操作和配置的规范，通过插件的形式对 CNI 接口进行实现。CNI 仅关注在创建容器时分配网络资源，和在销毁容器时删除网络资源。在 CNI 模型中只涉及两个概念：容器和网络。</p><ul><li>容器（Container）：是拥有独立 Linux 网络命名空间的环境，例如使用 Docker 或 rkt 创建的容器。容器需要拥有自己的 Linux 网络命名空间，这是加入网络的必要条件。</li><li>网络（Network）：表示可以互连的一组实体，这些实体拥有各自独立、唯一的 IP 地址，可以是容器、物理机或者其他网络设备（比如路由器）等。</li></ul><p>对容器网络的设置和操作都通过插件（Plugin）进行具体实现，CNI 插件包括两种类型：CNI Plugin 和 IPAM（IP Address Management）Plugin。CNI Plugin 负责为容器配置网络资源，IPAM Plugin 负责对容器的 IP 地址进行分配和管理。IPAM Plugin 作为 CNI Plugin 的一部分，与 CNI Plugin 协同工作。</p><h3 id="51-简述kubernetes网络策略"><a class="anchor" href="#51-简述kubernetes网络策略">#</a> 51、简述 Kubernetes 网络策略</h3><p>为实现细粒度的容器间网络访问隔离策略，Kubernetes 引入 Network Policy。</p><p>Network Policy 的主要功能是对 Pod 间的网络通信进行限制和准入控制，设置允许访问或禁止访问的客户端 Pod 列表。Network Policy 定义网络策略，配合策略控制器（Policy Controller）进行策略的实现。</p><h3 id="52-简述kubernetes网络策略原理"><a class="anchor" href="#52-简述kubernetes网络策略原理">#</a> 52、简述 Kubernetes 网络策略原理</h3><p>Network Policy 的工作原理主要为：policy controller 需要实现一个 API Listener，监听用户设置的 Network Policy 定义，并将网络访问规则通过各 Node 的 Agent 进行实际设置（Agent 则需要通过 CNI 网络插件实现）。</p><h3 id="53-简述kubernetes中flannel的作用"><a class="anchor" href="#53-简述kubernetes中flannel的作用">#</a> 53、简述 Kubernetes 中 flannel 的作用</h3><p>Flannel 可以用于 Kubernetes 底层网络的实现，主要作用有：</p><ul><li>它能协助 Kubernetes，给每一个 Node 上的 Docker 容器都分配互相不冲突的 IP 地址。</li><li>它能在这些 IP 地址之间建立一个覆盖网络（Overlay Network），通过这个覆盖网络，将数据包原封不动地传递到目标容器内。</li></ul><h3 id="54-简述kubernetes-calico网络组件实现原理"><a class="anchor" href="#54-简述kubernetes-calico网络组件实现原理">#</a> 54、简述 Kubernetes Calico 网络组件实现原理</h3><p>Calico 是一个基于 BGP 的纯三层的网络方案，与 OpenStack、Kubernetes、AWS、GCE 等云平台都能够良好地集成。</p><p>Calico 在每个计算节点都利用 Linux Kernel 实现了一个高效的 vRouter 来负责数据转发。每个 vRouter 都通过 BGP 协议把在本节点上运行的容器的路由信息向整个 Calico 网络广播，并自动设置到达其他节点的路由转发规则。</p><p>Calico 保证所有容器之间的数据流量都是通过 IP 路由的方式完成互联互通的。Calico 节点组网时可以直接利用数据中心的网络结构（L2 或者 L3），不需要额外的 NAT、隧道或者 Overlay Network，没有额外的封包解包，能够节约 CPU 运算，提高网络效率。</p><h3 id="55-简述kubernetes共享存储的作用"><a class="anchor" href="#55-简述kubernetes共享存储的作用">#</a> 55、简述 Kubernetes 共享存储的作用</h3><p>Kubernetes 对于有状态的容器应用或者对数据需要持久化的应用，因此需要更加可靠的存储来保存应用产生的重要数据，以便容器应用在重建之后仍然可以使用之前的数据。因此需要使用共享存储。</p><h3 id="56-简述kubernetes数据持久化的方式有哪些"><a class="anchor" href="#56-简述kubernetes数据持久化的方式有哪些">#</a> 56、简述 Kubernetes 数据持久化的方式有哪些</h3><p>Kubernetes 通过数据持久化来持久化保存重要数据，常见的方式有：</p><ul><li>EmptyDir（空目录）：没有指定要挂载宿主机上的某个目录，直接由 Pod 内保部映射到宿主机上。类似于 docker 中的 manager volume。</li><li>场景：<ul><li>只需要临时将数据保存在磁盘上，比如在合并 / 排序算法中；</li><li>作为两个容器的共享存储。</li></ul></li><li>特性：<ul><li>同个 pod 里面的不同容器，共享同一个持久化目录，当 pod 节点删除时，volume 的数据也会被删除。</li><li>emptyDir 的数据持久化的生命周期和使用的 pod 一致，一般是作为临时存储使用。</li></ul></li><li>Hostpath：将宿主机上已存在的目录或文件挂载到容器内部。类似于 docker 中的 bind mount 挂载方式。</li><li>特性：增加了 Pod 与节点之间的耦合。</li></ul><p>PersistentVolume（简称 PV）：如基于 NFS 服务的 PV，也可以基于 GFS 的 PV。它的作用是统一数据持久化目录，方便管理。</p><h3 id="57-简述kubernetes-pv和pvc"><a class="anchor" href="#57-简述kubernetes-pv和pvc">#</a> 57、简述 Kubernetes PV 和 PVC</h3><p>PV 是对底层网络共享存储的抽象，将共享存储定义为一种 “资源”。</p><p>PVC 则是用户对存储资源的一个 “申请”。</p><h3 id="58-简述kubernetes-pv生命周期内的阶段"><a class="anchor" href="#58-简述kubernetes-pv生命周期内的阶段">#</a> 58、简述 Kubernetes PV 生命周期内的阶段</h3><p>某个 PV 在生命周期中可能处于以下 4 个阶段（Phaes）之一。</p><ul><li>Available：可用状态，还未与某个 PVC 绑定。</li><li>Bound：已与某个 PVC 绑定。</li><li>Released：绑定的 PVC 已经删除，资源已释放，但没有被集群回收。</li><li>Failed：自动资源回收失败。</li></ul><h3 id="59-简述kubernetes所支持的存储供应模式"><a class="anchor" href="#59-简述kubernetes所支持的存储供应模式">#</a> 59、简述 Kubernetes 所支持的存储供应模式</h3><p>Kubernetes 支持两种资源的存储供应模式：静态模式（Static）和动态模式（Dynamic）。</p><ul><li>静态模式：集群管理员手工创建许多 PV，在定义 PV 时需要将后端存储的特性进行设置。</li><li>动态模式：集群管理员无须手工创建 PV，而是通过 StorageClass 的设置对后端存储进行描述，标记为某种类型。此时要求 PVC 对存储的类型进行声明，系统将自动完成 PV 的创建及与 PVC 的绑定。</li></ul><h3 id="60-简述kubernetes-csi模型"><a class="anchor" href="#60-简述kubernetes-csi模型">#</a> 60、简述 Kubernetes CSI 模型</h3><p>Kubernetes CSI 是 Kubernetes 推出与容器对接的存储接口标准，存储提供方只需要基于标准接口进行存储插件的实现，就能使用 Kubernetes 的原生存储机制为容器提供存储服务。CSI 使得存储提供方的代码能和 Kubernetes 代码彻底解耦，部署也与 Kubernetes 核心组件分离，显然，存储插件的开发由提供方自行维护，就能为 Kubernetes 用户提供更多的存储功能，也更加安全可靠。</p><p>CSI 包括 CSI Controller 和 CSI Node：</p><ul><li>CSI Controller 的主要功能是提供存储服务视角对存储资源和存储卷进行管理和操作。</li><li>CSI Node 的主要功能是对主机（Node）上的 Volume 进行管理和操作。</li></ul><h3 id="61-简述kubernetes-worker节点加入集群的过程"><a class="anchor" href="#61-简述kubernetes-worker节点加入集群的过程">#</a> 61、简述 Kubernetes Worker 节点加入集群的过程</h3><p>通常需要对 Worker 节点进行扩容，从而将应用系统进行水平扩展。主要过程如下：</p><ul><li>在该 Node 上安装 Docker、kubelet 和 kube-proxy 服务；</li><li>然后配置 kubelet 和 kubeproxy 的启动参数，将 Master URL 指定为当前 Kubernetes 集群 Master 的地址，最后启动这些服务；</li><li>通过 kubelet 默认的自动注册机制，新的 Worker 将会自动加入现有的 Kubernetes 集群中；</li><li>Kubernetes Master 在接受了新 Worker 的注册之后，会自动将其纳入当前集群的调度范围。</li></ul><h3 id="62-简述kubernetes-pod如何实现对节点的资源控制"><a class="anchor" href="#62-简述kubernetes-pod如何实现对节点的资源控制">#</a> 62、简述 Kubernetes Pod 如何实现对节点的资源控制</h3><p>Kubernetes 集群里的节点提供的资源主要是计算资源，计算资源是可计量的能被申请、分配和使用的基础资源。当前 Kubernetes 集群中的计算资源主要包括 CPU、GPU 及 Memory。CPU 与 Memory 是被 Pod 使用的，因此在配置 Pod 时可以通过参数 CPU Request 及 Memory Request 为其中的每个容器指定所需使用的 CPU 与 Memory 量，Kubernetes 会根据 Request 的值去查找有足够资源的 Node 来调度此 Pod。</p><p>通常，一个程序所使用的 CPU 与 Memory 是一个动态的量，确切地说，是一个范围，跟它的负载密切相关：负载增加时，CPU 和 Memory 的使用量也会增加。</p><h3 id="63-简述kubernetes-requests和limits如何影响pod的调度"><a class="anchor" href="#63-简述kubernetes-requests和limits如何影响pod的调度">#</a> 63、简述 Kubernetes Requests 和 Limits 如何影响 Pod 的调度</h3><p>当一个 Pod 创建成功时，Kubernetes 调度器（Scheduler）会为该 Pod 选择一个节点来执行。对于每种计算资源（CPU 和 Memory）而言，每个节点都有一个能用于运行 Pod 的最大容量值。调度器在调度时，首先要确保调度后该节点上所有 Pod 的 CPU 和内存的 Requests 总和，不超过该节点能提供给 Pod 使用的 CPU 和 Memory 的最大容量值。</p><h3 id="64-简述kubernetes-metric-service"><a class="anchor" href="#64-简述kubernetes-metric-service">#</a> 64、简述 Kubernetes Metric Service</h3><p>在 Kubernetes 从 1.10 版本后采用 Metrics Server 作为默认的性能数据采集和监控，主要用于提供核心指标（Core Metrics），包括 Node、Pod 的 CPU 和内存使用指标。</p><p>对其他自定义指标（Custom Metrics）的监控则由 Prometheus 等组件来完成。</p><h3 id="65-简述kubernetes中如何使用efk实现日志的统一管理"><a class="anchor" href="#65-简述kubernetes中如何使用efk实现日志的统一管理">#</a> 65、简述 Kubernetes 中，如何使用 EFK 实现日志的统一管理</h3><p>在 Kubernetes 集群环境中，通常一个完整的应用或服务涉及组件过多，建议对日志系统进行集中化管理，通常采用 EFK 实现。</p><p>EFK 是 Elasticsearch、Fluentd 和 Kibana 的组合，其各组件功能如下：</p><ul><li>Elasticsearch：是一个搜索引擎，负责存储日志并提供查询接口；</li><li>Fluentd：负责从 Kubernetes 搜集日志，每个 Node 节点上面的 Fluentd 监控并收集该节点上面的系统日志，并将处理过后的日志信息发送给 Elasticsearch；</li><li>Kibana：提供了一个 Web GUI，用户可以浏览和搜索存储在 Elasticsearch 中的日志。</li></ul><p>通过在每台 Node 上部署一个以 DaemonSet 方式运行的 Fluentd 来收集每台 Node 上的日志。Fluentd 将 Docker 日志目录 /var/lib/docker/containers 和 /var/log 目录挂载到 Pod 中，然后 Pod 会在 Node 节点的 /var/log/pods 目录中创建新的目录，可以区别不同的容器日志输出，该目录下有一个日志文件链接到 /var/lib/docker/contianers 目录下的容器日志输出。</p><h3 id="66-简述kubernetes如何进行优雅的节点关机维护"><a class="anchor" href="#66-简述kubernetes如何进行优雅的节点关机维护">#</a> 66、简述 Kubernetes 如何进行优雅的节点关机维护</h3><p>由于 Kubernetes 节点运行大量 Pod，因此在进行关机维护之前，建议先使用 kubectl drain 将该节点的 Pod 进行驱逐，然后进行关机维护。</p><h3 id="67-简述kubernetes集群联邦"><a class="anchor" href="#67-简述kubernetes集群联邦">#</a> 67、简述 Kubernetes 集群联邦</h3><p>Kubernetes 集群联邦可以将多个 Kubernetes 集群作为一个集群进行管理。因此，可以在一个数据中心 / 云中创建多个 Kubernetes 集群，并使用集群联邦在一个地方控制 / 管理所有集群。</p><h3 id="68-简述helm及其优势"><a class="anchor" href="#68-简述helm及其优势">#</a> 68、简述 Helm 及其优势</h3><p>Helm 是 Kubernetes 的软件包管理工具。类似 Ubuntu 中使用的 APT、CentOS 中使用的 yum 或者 Python 中的 pip 一样。</p><p>Helm 能够将一组 Kubernetes 资源打包统一管理，是查找、共享和使用为 Kubernetes 构建的软件的最佳方式。</p><p>Helm 中通常每个包称为一个 Chart，一个 Chart 是一个目录（一般情况下会将目录进行打包压缩，形成 name-version.tgz 格式的单一文件，方便传输和存储）。</p><p>在 Kubernetes 中部署一个可以使用的应用，需要涉及到很多的 Kubernetes 资源的共同协作。使用 Helm 则具有如下优势：</p><ul><li>统一管理、配置和更新这些分散的 Kubernetes 的应用资源文件；</li><li>分发和复用一套应用模板；</li><li>将应用的一系列资源当做一个软件包管理。</li><li>对于应用发布者而言，可以通过 Helm 打包应用、管理应用依赖关系、管理应用版本并发布应用到软件仓库。</li></ul><p>对于使用者而言，使用 Helm 后不用需要编写复杂的应用部署文件，可以以简单的方式在 Kubernetes 上查找、安装、升级、回滚、卸载应用程序。</p><h3 id="69-k8s是什么请说出你的了解"><a class="anchor" href="#69-k8s是什么请说出你的了解">#</a> 69、k8s 是什么？请说出你的了解？</h3><p>答：Kubenetes 是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。</p><p>K8S 是 Google 公司推出的，它来源于由 Google 公司内部使用了 15 年的 Borg 系统，集结了 Borg 的精华。</p><h3 id="70-k8s架构的组成是什么"><a class="anchor" href="#70-k8s架构的组成是什么">#</a> 70、K8s 架构的组成是什么？</h3><p>答：和大多数分布式系统一样，K8S 集群至少需要一个主节点（Master）和多个计算节点（Node）。</p><ul><li>主节点主要用于暴露 API，调度部署和节点的管理；</li><li>计算节点运行一个容器运行环境，一般是 docker 环境（类似 docker 环境的还有 rkt），同时运行一个 K8s 的代理（kubelet）用于和 master 通信。计算节点也会运行一些额外的组件，像记录日志，节点监控，服务发现等等。计算节点是 k8s 集群中真正工作的节点。</li></ul><h4 id="k8s架构细分"><a class="anchor" href="#k8s架构细分">#</a> K8S 架构细分：</h4><p>1、Master 节点（默认不参加实际工作）：</p><ul><li><p>Kubectl：客户端命令行工具，作为整个 K8s 集群的操作入口；</p></li><li><p>Api Server：在 K8s 架构中承担的是 “桥梁” 的角色，作为资源操作的唯一入口，它提供了认证、授权、访问控制、API 注册和发现等机制。客户端与 k8s 群集及 K8s 内部组件的通信，都要通过 Api Server 这个组件；</p></li><li><p>Controller-manager：负责维护群集的状态，比如故障检测、自动扩展、滚动更新等；</p></li><li><p>Scheduler：负责资源的调度，按照预定的调度策略将 pod 调度到相应的 node 节点上；</p></li><li><p>Etcd：担任数据中心的角色，保存了整个群集的状态；</p></li></ul><p>2、Node 节点：</p><ul><li><p>Kubelet：负责维护容器的生命周期，同时也负责 Volume 和网络的管理，一般运行在所有的节点，是 Node 节点的代理，当 Scheduler 确定某个 node 上运行 pod 之后，会将 pod 的具体信息（image，volume）等发送给该节点的 kubelet，kubelet 根据这些信息创建和运行容器，并向 master 返回运行状态。（自动修复功能：如果某个节点中的容器宕机，它会尝试重启该容器，若重启无效，则会将该 pod 杀死，然后重新创建一个容器）；</p></li><li><p>Kube-proxy：Service 在逻辑上代表了后端的多个 pod。负责为 Service 提供 cluster 内部的服务发现和负载均衡（外界通过 Service 访问 pod 提供的服务时，Service 接收到的请求后就是通过 kube-proxy 来转发到 pod 上的）；</p></li><li><p>container-runtime：是负责管理运行容器的软件，比如 docker</p></li><li><p>Pod：是 k8s 集群里面最小的单位。每个 pod 里边可以运行一个或多个 container（容器），如果一个 pod 中有两个 container，那么 container 的 USR（用户）、MNT（挂载点）、PID（进程号）是相互隔离的，UTS（主机名和域名）、IPC（消息队列）、NET（网络栈）是相互共享的。我比较喜欢把 pod 来当做豌豆夹，而豌豆就是 pod 中的 container；</p></li></ul><h3 id="71-容器和主机部署应用的区别是什么"><a class="anchor" href="#71-容器和主机部署应用的区别是什么">#</a> 71、容器和主机部署应用的区别是什么？</h3><p>答：容器的中心思想就是秒级启动；一次封装、到处运行；这是主机部署应用无法达到的效果，但同时也更应该注重容器的数据持久化问题。</p><p>另外，容器部署可以将各个服务进行隔离，互不影响，这也是容器的另一个核心概念。</p><h3 id="72-请你说一下kubenetes针对pod资源对象的健康监测机制"><a class="anchor" href="#72-请你说一下kubenetes针对pod资源对象的健康监测机制">#</a> 72、请你说一下 kubenetes 针对 pod 资源对象的健康监测机制？</h3><p>答：K8s 中对于 pod 资源对象的健康状态检测，提供了三类 probe（探针）来执行对 pod 的健康监测：</p><p>1） <code>livenessProbe</code> 探针</p><p>可以根据用户自定义规则来判定 pod 是否健康，如果 livenessProbe 探针探测到容器不健康，则 kubelet 会根据其重启策略来决定是否重启，如果一个容器不包含 livenessProbe 探针，则 kubelet 会认为容器的 livenessProbe 探针的返回值永远成功。</p><p>2） <code>ReadinessProbe</code> 探针</p><p>同样是可以根据用户自定义规则来判断 pod 是否健康，如果探测失败，控制器会将此 pod 从对应 service 的 endpoint 列表中移除，从此不再将任何请求调度到此 Pod 上，直到下次探测成功。</p><p>3） <code>startupProbe</code> 探针</p><p>启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针 kill 掉，这个问题也可以换另一种方式解决，就是定义上面两类探针机制时，初始化时间定义的长一些即可。</p><p>每种探测方法能支持以下几个相同的检查参数，用于设置控制检查时间：</p><ul><li><p><code>initialDelaySeconds</code> ：初始第一次探测间隔，用于应用启动的时间，防止应用还没启动而健康检查失败</p></li><li><p><code>periodSeconds</code> ：检查间隔，多久执行 probe 检查，默认为 10s；</p></li><li><p><code>timeoutSeconds</code> ：检查超时时长，探测应用 timeout 后为失败；</p></li><li><p><code>successThreshold</code> ：成功探测阈值，表示探测多少次为健康正常，默认探测 1 次。</p></li></ul><p>上面两种探针都支持以下三种探测方法：</p><p>1）Exec：通过执行命令的方式来检查服务是否正常，比如使用 cat 命令查看 pod 中的某个重要配置文件是否存在，若存在，则表示 pod 健康。反之异常。</p><p>Exec 探测方式的 yaml 文件语法如下：</p><figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">spec</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">containers</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/busybox</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token key atrule">args</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">-</span> /bin/sh</pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">-</span> <span class="token punctuation">-</span>c</pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">-</span> touch /tmp/healthy; sleep 30; rm <span class="token punctuation">-</span>rf /tmp/healthy; sleep 600</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>         <span class="token comment">#选择 livenessProbe 的探测机制</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token key atrule">exec</span><span class="token punctuation">:</span>                      <span class="token comment">#执行以下命令</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token key atrule">command</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">-</span> cat</pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">-</span> /tmp/healthy</pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>          <span class="token comment">#在容器运行五秒后开始探测</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>               <span class="token comment">#每次探测的时间间隔为 5 秒</span></pre></td></tr></table></figure><p>在上面的配置文件中，探测机制为在容器运行 5 秒后，每隔五秒探测一次，如果 cat 命令返回的值为 “0”，则表示健康，如果为非 0，则表示异常。</p><p>2）Httpget：通过发送 http/htps 请求检查服务是否正常，返回的状态码为 200-399 则表示容器健康（注 http get 类似于命令 <code>curl -I</code> ）。</p><p>Httpget 探测方式的 yaml 文件语法如下：</p><figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">spec</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">containers</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> liveness</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/liveness</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>              <span class="token comment">#采用 livenessProbe 机制探测</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>                  <span class="token comment">#采用 httpget 的方式</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    scheme<span class="token punctuation">:</span>HTTP         <span class="token comment">#指定协议，也支持 https</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token key atrule">path</span><span class="token punctuation">:</span> /healthz          <span class="token comment">#检测是否可以访问到网页根目录下的 healthz 网页文件</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>              <span class="token comment">#监听端口是 8080</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">3</span>     <span class="token comment">#容器运行 3 秒后开始探测</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">3</span>                <span class="token comment">#探测频率为 3 秒</span></pre></td></tr></table></figure><p>上述配置文件中，探测方式为项容器发送 HTTP GET 请求，请求的是 8080 端口下的 healthz 文件，返回任何大于或等于 200 且小于 400 的状态码表示成功。任何其他代码表示异常。</p><p>3）tcpSocket：通过容器的 IP 和 Port 执行 TCP 检查，如果能够建立 TCP 连接，则表明容器健康，这种方式与 HTTPget 的探测机制有些类似，tcpsocket 健康检查适用于 TCP 业务。</p><p>tcpSocket 探测方式的 yaml 文件语法如下：</p><figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">spec</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">containers</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> goproxy</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token key atrule">image</span><span class="token punctuation">:</span> k8s.gcr.io/goproxy<span class="token punctuation">:</span><span class="token number">0.1</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token key atrule">ports</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">#这里两种探测机制都用上了，都是为了和容器的 8080 端口建立 TCP 连接</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token key atrule">tcpSocket</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">5</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">10</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token key atrule">tcpSocket</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">15</span></pre></td></tr><tr><td data-num="17"></td><td><pre>      <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">20</span></pre></td></tr></table></figure><p>在上述的 yaml 配置文件中，两类探针都使用了，在容器启动 5 秒后，kubelet 将发送第一个 readinessProbe 探针，这将连接容器的 8080 端口，如果探测成功，则该 pod 为健康，十秒后，kubelet 将进行第二次连接。</p><p>除了 readinessProbe 探针外，在容器启动 15 秒后，kubelet 将发送第一个 livenessProbe 探针，仍然尝试连接容器的 8080 端口，如果连接失败，则重启容器。</p><p>探针探测的结果无外乎以下三者之一：</p><ul><li><p>Success：Container 通过了检查；</p></li><li><p>Failure：Container 没有通过检查；</p></li><li><p>Unknown：没有执行检查，因此不采取任何措施（通常是我们没有定义探针检测，默认为成功）。</p></li></ul><p>若觉得上面还不够透彻，可以移步其官网文档：</p><p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdGFza3MvY29uZmlndXJlLXBvZC1jb250YWluZXIvY29uZmlndXJlLWxpdmVuZXNzLXJlYWRpbmVzcy1zdGFydHVwLXByb2Jlcy8=">https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/</span></p><h3 id="73-如何控制滚动更新过程"><a class="anchor" href="#73-如何控制滚动更新过程">#</a> 73、如何控制滚动更新过程？</h3><p>答：可以通过下面的命令查看到更新时可以控制的参数：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@master yaml<span class="token punctuation">]</span><span class="token comment"># kubectl explain deploy.spec.strategy.rollingUpdate</span></pre></td></tr></table></figure><p><code>maxSurge</code> ： 此参数控制滚动更新过程，副本总数超过预期 pod 数量的上限。可以是百分比，也可以是具体的值。默认为 1。</p><p>（上述参数的作用就是在更新过程中，值若为 3，那么不管三七二一，先运行三个 pod，用于替换旧的 pod，以此类推）</p><p><code>maxUnavailable</code> ：此参数控制滚动更新过程中，不可用的 Pod 的数量。</p><p>（这个值和上面的值没有任何关系，举个例子：我有十个 pod，但是在更新的过程中，我允许这十个 pod 中最多有三个不可用，那么就将这个参数的值设置为 3，在更新的过程中，只要不可用的 pod 数量小于或等于 3，那么更新过程就不会停止）。</p><h3 id="74-k8s中镜像的下载策略是什么"><a class="anchor" href="#74-k8s中镜像的下载策略是什么">#</a> 74、K8s 中镜像的下载策略是什么？</h3><p>答：可通过命令 “kubectl explain pod.spec.containers” 来查看 imagePullPolicy 这行的解释。</p><p>K8s 的镜像下载策略有三种：Always、Never、IFNotPresent；</p><ul><li><p>Always：镜像标签为 latest 时，总是从指定的仓库中获取镜像；</p></li><li><p>Never：禁止从仓库中下载镜像，也就是说只能使用本地镜像；</p></li><li><p>IfNotPresent：仅当本地没有对应镜像时，才从目标仓库中下载。</p></li><li><p>默认的镜像下载策略是：当镜像标签是 latest 时，默认策略是 Always；当镜像标签是自定义时（也就是标签不是 latest），那么默认策略是 IfNotPresent。</p></li></ul><h3 id="75-image的状态有哪些"><a class="anchor" href="#75-image的状态有哪些">#</a> 75、image 的状态有哪些？</h3><ul><li><p>Running：Pod 所需的容器已经被成功调度到某个节点，且已经成功运行，</p></li><li><p>Pending：APIserver 创建了 pod 资源对象，并且已经存入 etcd 中，但它尚未被调度完成或者仍然处于仓库中下载镜像的过程</p></li><li><p>Unknown：APIserver 无法正常获取到 pod 对象的状态，通常是其无法与所在工作节点的 kubelet 通信所致。</p></li></ul><h3 id="76-pod的重启策略是什么"><a class="anchor" href="#76-pod的重启策略是什么">#</a> 76、pod 的重启策略是什么？</h3><p>答：可以通过命令 “kubectl explain pod.spec” 查看 pod 的重启策略。（restartPolicy 字段）</p><ul><li>Always：但凡 pod 对象终止就重启，此为默认策略。</li><li>OnFailure：仅在 pod 对象出现错误时才重启</li></ul><h3 id="77-service这种资源对象的作用是什么"><a class="anchor" href="#77-service这种资源对象的作用是什么">#</a> 77、Service 这种资源对象的作用是什么？</h3><p>答：用来给相同的多个 pod 对象提供一个固定的统一访问接口，常用于服务发现和服务访问。</p><h3 id="78-版本回滚相关的命令"><a class="anchor" href="#78-版本回滚相关的命令">#</a> 78、版本回滚相关的命令？</h3><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@master httpd-web<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f httpd2-deploy1.yaml  --record  </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">#运行 yaml 文件，并记录版本信息；</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span>root@master httpd-web<span class="token punctuation">]</span><span class="token comment"># kubectl rollout history deployment httpd-devploy1  </span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">#查看该 deployment 的历史版本</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">[</span>root@master httpd-web<span class="token punctuation">]</span><span class="token comment"># kubectl rollout undo deployment httpd-devploy1 --to-revision=1    </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">#执行回滚操作，指定回滚到版本 1</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">#在 yaml 文件的 spec 字段中，可以写以下选项（用于限制最多记录多少个历史版本）：</span></pre></td></tr><tr><td data-num="8"></td><td><pre>spec:</pre></td></tr><tr><td data-num="9"></td><td><pre>  revisionHistoryLimit: <span class="token number">5</span>            </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">#这个字段通过 kubectl explain deploy.spec  命令找到 revisionHistoryLimit   &lt;integer > 行获得</span></pre></td></tr></table></figure><h3 id="79-标签与标签选择器的作用是什么"><a class="anchor" href="#79-标签与标签选择器的作用是什么">#</a> 79、标签与标签选择器的作用是什么？</h3><p>标签：是当相同类型的资源对象越来越多的时候，为了更好的管理，可以按照标签将其分为一个组，为的是提升资源对象的管理效率。</p><p>标签选择器：就是标签的查询过滤条件。目前 API 支持两种标签选择器：</p><ul><li>基于等值关系的，如：“=”、“”“<mark>”、“！=”（注：“</mark>” 也是等于的意思，yaml 文件中的 matchLabels 字段）；</li><li>基于集合的，如：in、notin、exists（yaml 文件中的 matchExpressions 字段）；</li></ul><p>注：in: 在这个集合中；notin：不在这个集合中；exists：要么全在（exists）这个集合中，要么都不在（notexists）；</p><p>使用标签选择器的操作逻辑：</p><ul><li><p>在使用基于集合的标签选择器同时指定多个选择器之间的逻辑关系为 “与” 操作（比如：- {key: name,operator: In,values: [zhangsan,lisi]} ，那么只要拥有这两个值的资源，都会被选中）；</p></li><li><p>使用空值的标签选择器，意味着每个资源对象都被选中（如：标签选择器的键是 “A”，两个资源对象同时拥有 A 这个键，但是值不一样，这种情况下，如果使用空值的标签选择器，那么将同时选中这两个资源对象）</p></li><li><p>空的标签选择器（注意不是上面说的空值，而是空的，都没有定义键的名称），将无法选择出任何资源；</p></li></ul><p>在基于集合的选择器中，使用 “In” 或者 “Notin” 操作时，其 values 可以为空，但是如果为空，这个标签选择器，就没有任何意义了。</p><p>两种标签选择器类型（基于等值、基于集合的书写方法）：</p><figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">selector</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>           <span class="token comment">#基于等值</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx</pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>         <span class="token comment">#基于集合</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">-</span> <span class="token punctuation">&#123;</span><span class="token key atrule">key</span><span class="token punctuation">:</span> name<span class="token punctuation">,</span><span class="token key atrule">operator</span><span class="token punctuation">:</span> In<span class="token punctuation">,</span><span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>zhangsan<span class="token punctuation">,</span>lisi<span class="token punctuation">]</span><span class="token punctuation">&#125;</span>     <span class="token comment">#key、operator、values 这三个字段是固定的</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">-</span> <span class="token punctuation">&#123;</span><span class="token key atrule">key</span><span class="token punctuation">:</span> age<span class="token punctuation">,</span><span class="token key atrule">operator</span><span class="token punctuation">:</span> Exists<span class="token punctuation">,</span>values<span class="token punctuation">:</span><span class="token punctuation">&#125;</span>   <span class="token comment">#如果指定为 exists，那么 values 的值一定要为空</span></pre></td></tr></table></figure><h3 id="80-常用的标签分类有哪些"><a class="anchor" href="#80-常用的标签分类有哪些">#</a> 80、常用的标签分类有哪些？</h3><p>标签分类是可以自定义的，但是为了能使他人可以达到一目了然的效果，一般会使用以下一些分类：</p><ul><li><p>版本类标签（release）：stable（稳定版）、canary（金丝雀版本，可以将其称之为测试版中的测试版）、beta（测试版）；</p></li><li><p>环境类标签（environment）：dev（开发）、qa（测试）、production（生产）、op（运维）；</p></li><li><p>应用类（app）：ui、as、pc、sc；</p></li><li><p>架构类（tier）：frontend（前端）、backend（后端）、cache（缓存）；</p></li><li><p>分区标签（partition）：customerA（客户 A）、customerB（客户 B）；</p></li><li><p>品控级别（Track）：daily（每天）、weekly（每周）。</p></li></ul><h3 id="81-有几种查看标签的方式"><a class="anchor" href="#81-有几种查看标签的方式">#</a> 81、有几种查看标签的方式？</h3><p>答：常用的有以下三种查看方式：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl get pod --show-labels    #查看 pod，并且显示标签内容</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl get pod -L env,tier      #显示资源对象标签的值</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl get pod -l env,tier      #只显示符合键值资源对象的 pod，而 “-L” 是显示所有的 pod</span></pre></td></tr></table></figure><h3 id="82-添加-修改-删除标签的命令"><a class="anchor" href="#82-添加-修改-删除标签的命令">#</a> 82、添加、修改、删除标签的命令？</h3><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">#对 pod 标签的操作</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl label pod label-pod abc=123     #给名为 label-pod 的 pod 添加标签</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl label pod label-pod abc=456 --overwrite       #修改名为 label-pod 的标签</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl label pod label-pod abc-             #删除名为 label-pod 的标签</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl get pod --show-labels</span></pre></td></tr><tr><td data-num="6"></td><td><pre> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">#对 node 节点的标签操作   </span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl label nodes node01 disk=ssd      #给节点 node01 添加 disk 标签</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl label nodes node01 disk=sss –overwrite    #修改节点 node01 的标签</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">[</span>root@master ~<span class="token punctuation">]</span><span class="token comment"># kubectl label nodes node01 disk-         #删除节点 node01 的 disk 标签</span></pre></td></tr></table></figure><h3 id="83-daemonset资源对象的特性"><a class="anchor" href="#83-daemonset资源对象的特性">#</a> 83、DaemonSet 资源对象的特性？</h3><p>DaemonSet 这种资源对象会在每个 k8s 集群中的节点上运行，并且每个节点只能运行一个 pod，这是它和 deployment 资源对象的最大也是唯一的区别。所以，在其 yaml 文件中，不支持定义 replicas，除此之外，与 Deployment、RS 等资源对象的写法相同。</p><p>它的一般使用场景如下：</p><ul><li>在去做每个节点的日志收集工作；</li><li>监控每个节点的的运行状态；</li></ul><h3 id="84-说说你对job这种资源对象的了解"><a class="anchor" href="#84-说说你对job这种资源对象的了解">#</a> 84、说说你对 Job 这种资源对象的了解？</h3><p>答：Job 与其他服务类容器不同，Job 是一种工作类容器（一般用于做一次性任务）。使用常见不多，可以忽略这个问题。</p><figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">#提高 Job 执行效率的方法：</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key atrule">spec</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token key atrule">parallelism</span><span class="token punctuation">:</span> <span class="token number">2</span>           <span class="token comment">#一次运行 2 个</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token key atrule">completions</span><span class="token punctuation">:</span> <span class="token number">8</span>           <span class="token comment">#最多运行 8 个</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token key atrule">template</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>metadata<span class="token punctuation">:</span></pre></td></tr></table></figure><h3 id="85-描述一下pod的生命周期有哪些状态"><a class="anchor" href="#85-描述一下pod的生命周期有哪些状态">#</a> 85、描述一下 pod 的生命周期有哪些状态？</h3><ul><li><p>Pending：表示 pod 已经被同意创建，正在等待 kube-scheduler 选择合适的节点创建，一般是在准备镜像；</p></li><li><p>Running：表示 pod 中所有的容器已经被创建，并且至少有一个容器正在运行或者是正在启动或者是正在重启；</p></li><li><p>Succeeded：表示所有容器已经成功终止，并且不会再启动；</p></li><li><p>Failed：表示 pod 中所有容器都是非 0（不正常）状态退出；</p></li><li><p>Unknown：表示无法读取 Pod 状态，通常是 kube-controller-manager 无法与 Pod 通信。</p></li></ul><h3 id="86-创建一个pod的流程是什么"><a class="anchor" href="#86-创建一个pod的流程是什么">#</a> 86、创建一个 pod 的流程是什么？</h3><ul><li><p>客户端提交 Pod 的配置信息（可以是 yaml 文件定义好的信息）到 kube-apiserver；</p></li><li><p>Apiserver 收到指令后，通知给 controller-manager 创建一个资源对象；</p></li><li><p>Controller-manager 通过 api-server 将 pod 的配置信息存储到 ETCD 数据中心中；</p></li><li><p>Kube-scheduler 检测到 pod 信息会开始调度预选，会先过滤掉不符合 Pod 资源配置要求的节点，然后开始调度调优，主要是挑选出更适合运行 pod 的节点，然后将 pod 的资源配置单发送到 node 节点上的 kubelet 组件上。</p></li><li><p>Kubelet 根据 scheduler 发来的资源配置单运行 pod，运行成功后，将 pod 的运行信息返回给 scheduler，scheduler 将返回的 pod 运行状况的信息存储到 etcd 数据中心。</p></li></ul><h3 id="87-删除一个pod会发生什么事情"><a class="anchor" href="#87-删除一个pod会发生什么事情">#</a> 87、删除一个 Pod 会发生什么事情？</h3><p>答：Kube-apiserver 会接受到用户的删除指令，默认有 30 秒时间等待优雅退出，超过 30 秒会被标记为死亡状态，此时 Pod 的状态 Terminating，kubelet 看到 pod 标记为 Terminating 就开始了关闭 Pod 的工作；</p><p>关闭流程如下：</p><ul><li><p>pod 从 service 的 endpoint 列表中被移除；</p></li><li><p>如果该 pod 定义了一个停止前的钩子，其会在 pod 内部被调用，停止钩子一般定义了如何优雅的结束进程；</p></li><li><p>进程被发送 TERM 信号（kill -14）</p></li><li><p>当超过优雅退出的时间后，Pod 中的所有进程都会被发送 SIGKILL 信号（kill -9）。</p></li></ul><h3 id="88-k8s的service是什么"><a class="anchor" href="#88-k8s的service是什么">#</a> 88、K8s 的 Service 是什么？</h3><p>答：Pod 每次重启或者重新部署，其 IP 地址都会产生变化，这使得 pod 间通信和 pod 与外部通信变得困难，这时候，就需要 Service 为 pod 提供一个固定的入口。</p><p>Service 的 Endpoint 列表通常绑定了一组相同配置的 pod，通过负载均衡的方式把外界请求分配到多个 pod 上</p><h3 id="89-k8s是怎么进行服务注册的"><a class="anchor" href="#89-k8s是怎么进行服务注册的">#</a> 89、k8s 是怎么进行服务注册的？</h3><p>答：Pod 启动后会加载当前环境所有 Service 信息，以便不同 Pod 根据 Service 名进行通信。</p><h3 id="90-k8s集群外流量怎么访问pod"><a class="anchor" href="#90-k8s集群外流量怎么访问pod">#</a> 90、k8s 集群外流量怎么访问 Pod？</h3><p>答：可以通过 Service 的 NodePort 方式访问，会在所有节点监听同一个端口，比如：30000，访问节点的流量会被重定向到对应的 Service 上面。</p><h3 id="91-k8s数据持久化的方式有哪些"><a class="anchor" href="#91-k8s数据持久化的方式有哪些">#</a> 91、k8s 数据持久化的方式有哪些？</h3><p>答：</p><h4 id="1emptydir空目录"><a class="anchor" href="#1emptydir空目录">#</a> 1）EmptyDir（空目录）：</h4><p>没有指定要挂载宿主机上的某个目录，直接由 Pod 内保部映射到宿主机上。类似于 docker 中的 manager volume。</p><p>主要使用场景：</p><ul><li>只需要临时将数据保存在磁盘上，比如在合并 / 排序算法中；</li><li>作为两个容器的共享存储，使得第一个内容管理的容器可以将生成的数据存入其中，同时由同一个 webserver 容器对外提供这些页面。</li></ul><p>emptyDir 的特性：</p><p>同个 pod 里面的不同容器，共享同一个持久化目录，当 pod 节点删除时，volume 的数据也会被删除。如果仅仅是容器被销毁，pod 还在，则不会影响 volume 中的数据。</p><p>总结来说：emptyDir 的数据持久化的生命周期和使用的 pod 一致。一般是作为临时存储使用。</p><h4 id="2hostpath"><a class="anchor" href="#2hostpath">#</a> 2）Hostpath：</h4><p>将宿主机上已存在的目录或文件挂载到容器内部。类似于 docker 中的 bind mount 挂载方式。</p><p>这种数据持久化方式，运用场景不多，因为它增加了 pod 与节点之间的耦合。</p><p>一般对于 k8s 集群本身的数据持久化和 docker 本身的数据持久化会使用这种方式，可以自行参考 apiService 的 yaml 文件，位于：/etc/kubernetes/main… 目录下。</p><h4 id="3persistentvolume简称pv"><a class="anchor" href="#3persistentvolume简称pv">#</a> 3）PersistentVolume（简称 PV）：</h4><p>基于 NFS 服务的 PV，也可以基于 GFS 的 PV。它的作用是统一数据持久化目录，方便管理。</p><p>在一个 PV 的 yaml 文件中，可以对其配置 PV 的大小，指定 PV 的访问模式：</p><ul><li><p><code>ReadWriteOnce</code> ：只能以读写的方式挂载到单个节点；</p></li><li><p><code>ReadOnlyMany</code> ：能以只读的方式挂载到多个节点；</p></li><li><p><code>ReadWriteMany</code> ：能以读写的方式挂载到多个节点。以及指定 pv 的回收策略：</p></li><li><p><code>recycle</code> ：清除 PV 的数据，然后自动回收；</p></li><li><p><code>Retain</code> ：需要手动回收；</p></li><li><p><code>delete</code> ：删除云存储资源，云存储专用；</p></li></ul><p>PS：这里的回收策略指的是在 PV 被删除后，在这个 PV 下所存储的源文件是否删除）。</p><p>若需使用 PV，那么还有一个重要的概念：PVC，PVC 是向 PV 申请应用所需的容量大小，K8s 集群中可能会有多个 PV，PVC 和 PV 若要关联，其定义的访问模式必须一致。定义的 storageClassName 也必须一致，若群集中存在相同的（名字、访问模式都一致）两个 PV，那么 PVC 会选择向它所需容量接近的 PV 去申请，或者随机申请。</p></div><footer><div class="meta"></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/08/20/leetcode/Leetcode2816/" itemprop="url" rel="prev" data-background-image="&#x2F;assets&#x2F;lc.jpeg" title="Leetcode"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Leetcode</span><h3>Leetcode</h3></a></div><div class="item right"><a href="/2023/08/21/article/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicli3sbvtj20zk0m8x6p.jpg" title="知识管理工作流"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 文章</span><h3>知识管理工作流</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E8%BF%B0etcd%E5%8F%8A%E5%85%B6%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">1、简述 etcd 及其特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AE%80%E8%BF%B0etcd%E9%80%82%E5%BA%94%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">2.</span> <span class="toc-text">2、简述 etcd 适应的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AE%80%E8%BF%B0%E4%BB%80%E4%B9%88%E6%98%AFkubernetes"><span class="toc-number">3.</span> <span class="toc-text">3、简述什么是 Kubernetes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%80%E8%BF%B0kubernetes%E5%92%8Cdocker%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.</span> <span class="toc-text">4、简述 Kubernetes 和 Docker 的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%AE%80%E8%BF%B0minikube-kubectl-kubelet%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.</span> <span class="toc-text">5、简述 Minikube、Kubectl、Kubelet 分别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%AE%80%E8%BF%B0kubernetes%E5%B8%B8%E8%A7%81%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">6、简述 Kubernetes 常见的部署方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%AE%80%E8%BF%B0kubernetes%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">7、简述 Kubernetes 如何实现集群管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%AE%80%E8%BF%B0kubernetes%E7%9A%84%E4%BC%98%E5%8A%BF-%E9%80%82%E5%BA%94%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%85%B6%E7%89%B9%E7%82%B9"><span class="toc-number">8.</span> <span class="toc-text">8、简述 Kubernetes 的优势、适应场景及其特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%AE%80%E8%BF%B0kubernetes%E7%9A%84%E7%BC%BA%E7%82%B9%E6%88%96%E5%BD%93%E5%89%8D%E7%9A%84%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84"><span class="toc-number">9.</span> <span class="toc-text">9、简述 Kubernetes 的缺点或当前的不足之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%AE%80%E8%BF%B0kubernetes%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">10.</span> <span class="toc-text">10、简述 Kubernetes 相关基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%AE%80%E8%BF%B0kubernetes%E9%9B%86%E7%BE%A4%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6"><span class="toc-number">11.</span> <span class="toc-text">11、简述 Kubernetes 集群相关组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%AE%80%E8%BF%B0kubernetes-rc%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">12.</span> <span class="toc-text">12、简述 Kubernetes RC 的机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%AE%80%E8%BF%B0kubernetes-replica-set%E5%92%8Creplication-controller%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">13、简述 Kubernetes Replica Set 和 Replication Controller 之间有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E7%AE%80%E8%BF%B0kube-proxy%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">14.</span> <span class="toc-text">14、简述 kube-proxy 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E7%AE%80%E8%BF%B0kube-proxy-iptables%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">15.</span> <span class="toc-text">15、简述 kube-proxy iptables 的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E7%AE%80%E8%BF%B0kube-proxy-ipvs%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">16.</span> <span class="toc-text">16、简述 kube-proxy ipvs 的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E7%AE%80%E8%BF%B0kube-proxy-ipvs%E5%92%8Ciptables%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">17.</span> <span class="toc-text">17、简述 kube-proxy ipvs 和 iptables 的异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E7%AE%80%E8%BF%B0kubernetes%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81pod"><span class="toc-number">18.</span> <span class="toc-text">18、简述 Kubernetes 中什么是静态 Pod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E7%AE%80%E8%BF%B0kubernetes%E4%B8%ADpod%E5%8F%AF%E8%83%BD%E4%BD%8D%E4%BA%8E%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">19.</span> <span class="toc-text">19、简述 Kubernetes 中 Pod 可能位于的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E7%AE%80%E8%BF%B0kubernetes%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AApod%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B"><span class="toc-number">20.</span> <span class="toc-text">20、简述 Kubernetes 创建一个 Pod 的主要流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E7%AE%80%E8%BF%B0kubernetes%E4%B8%ADpod%E7%9A%84%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5"><span class="toc-number">21.</span> <span class="toc-text">21、简述 Kubernetes 中 Pod 的重启策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E7%AE%80%E8%BF%B0kubernetes%E4%B8%ADpod%E7%9A%84%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">22.</span> <span class="toc-text">22、简述 Kubernetes 中 Pod 的健康检查方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E7%AE%80%E8%BF%B0kubernetes-pod%E7%9A%84livenessprobe%E6%8E%A2%E9%92%88%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F"><span class="toc-number">23.</span> <span class="toc-text">23、简述 Kubernetes Pod 的 LivenessProbe 探针的常见方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E7%AE%80%E8%BF%B0kubernetes-pod%E7%9A%84%E5%B8%B8%E8%A7%81%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-number">24.</span> <span class="toc-text">24、简述 Kubernetes Pod 的常见调度方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E7%AE%80%E8%BF%B0kubernetes%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E5%99%A8init-container"><span class="toc-number">25.</span> <span class="toc-text">25、简述 Kubernetes 初始化容器（init container）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E7%AE%80%E8%BF%B0kubernetes-deployment%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-number">26.</span> <span class="toc-text">26、简述 Kubernetes deployment 升级过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E7%AE%80%E8%BF%B0kubernetes-deployment%E5%8D%87%E7%BA%A7%E7%AD%96%E7%95%A5"><span class="toc-number">27.</span> <span class="toc-text">27、简述 Kubernetes deployment 升级策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E7%AE%80%E8%BF%B0kubernetes-daemonset%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%B5%84%E6%BA%90%E7%89%B9%E6%80%A7"><span class="toc-number">28.</span> <span class="toc-text">28、简述 Kubernetes DaemonSet 类型的资源特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E7%AE%80%E8%BF%B0kubernetes%E8%87%AA%E5%8A%A8%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">29.</span> <span class="toc-text">29、简述 Kubernetes 自动扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E7%AE%80%E8%BF%B0kubernetes-service%E7%B1%BB%E5%9E%8B"><span class="toc-number">30.</span> <span class="toc-text">30、简述 Kubernetes Service 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E7%AE%80%E8%BF%B0kubernetes-service%E5%88%86%E5%8F%91%E5%90%8E%E7%AB%AF%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">31.</span> <span class="toc-text">31、简述 Kubernetes Service 分发后端的策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E7%AE%80%E8%BF%B0kubernetes-headless-service"><span class="toc-number">32.</span> <span class="toc-text">32、简述 Kubernetes Headless Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E7%AE%80%E8%BF%B0kubernetes%E5%A4%96%E9%83%A8%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E9%9B%86%E7%BE%A4%E5%86%85%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">33.</span> <span class="toc-text">33、简述 Kubernetes 外部如何访问集群内的服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E7%AE%80%E8%BF%B0kubernetes-ingress"><span class="toc-number">34.</span> <span class="toc-text">34、简述 Kubernetes ingress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E7%AE%80%E8%BF%B0kubernetes%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%8B%E8%BD%BD%E7%AD%96%E7%95%A5"><span class="toc-number">35.</span> <span class="toc-text">35、简述 Kubernetes 镜像的下载策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E7%AE%80%E8%BF%B0kubernetes%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8"><span class="toc-number">36.</span> <span class="toc-text">36、简述 Kubernetes 的负载均衡器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E7%AE%80%E8%BF%B0kubernetes%E5%90%84%E6%A8%A1%E5%9D%97%E5%A6%82%E4%BD%95%E4%B8%8Eapi-server%E9%80%9A%E4%BF%A1"><span class="toc-number">37.</span> <span class="toc-text">37、简述 Kubernetes 各模块如何与 API Server 通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E7%AE%80%E8%BF%B0kubernetes-scheduler%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">38.</span> <span class="toc-text">38、简述 Kubernetes Scheduler 作用及实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E7%AE%80%E8%BF%B0kubernetes-scheduler%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95%E5%B0%86pod%E7%BB%91%E5%AE%9A%E5%88%B0worker%E8%8A%82%E7%82%B9"><span class="toc-number">39.</span> <span class="toc-text">39、简述 Kubernetes Scheduler 使用哪两种算法将 Pod 绑定到 worker 节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E7%AE%80%E8%BF%B0kubernetes-kubelet%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">40.</span> <span class="toc-text">40、简述 Kubernetes kubelet 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E7%AE%80%E8%BF%B0kubernetes-kubelet%E7%9B%91%E6%8E%A7worker%E8%8A%82%E7%82%B9%E8%B5%84%E6%BA%90%E6%98%AF%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">41.</span> <span class="toc-text">41、简述 Kubernetes kubelet 监控 Worker 节点资源是使用什么组件来实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E7%AE%80%E8%BF%B0kubernetes%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">42.</span> <span class="toc-text">42、简述 Kubernetes 如何保证集群的安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E7%AE%80%E8%BF%B0kubernetes%E5%87%86%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">43.</span> <span class="toc-text">43、简述 Kubernetes 准入机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E7%AE%80%E8%BF%B0kubernetes-rbac%E5%8F%8A%E5%85%B6%E7%89%B9%E7%82%B9%E4%BC%98%E5%8A%BF"><span class="toc-number">44.</span> <span class="toc-text">44、简述 Kubernetes RBAC 及其特点（优势）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E7%AE%80%E8%BF%B0kubernetes-secret%E4%BD%9C%E7%94%A8"><span class="toc-number">45.</span> <span class="toc-text">45、简述 Kubernetes Secret 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E7%AE%80%E8%BF%B0kubernetes-secret%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">46.</span> <span class="toc-text">46、简述 Kubernetes Secret 有哪些使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E7%AE%80%E8%BF%B0kubernetes-podsecuritypolicy%E6%9C%BA%E5%88%B6"><span class="toc-number">47.</span> <span class="toc-text">47、简述 Kubernetes PodSecurityPolicy 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E7%AE%80%E8%BF%B0kubernetes-podsecuritypolicy%E6%9C%BA%E5%88%B6%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%93%AA%E4%BA%9B%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5"><span class="toc-number">48.</span> <span class="toc-text">48、简述 Kubernetes PodSecurityPolicy 机制能实现哪些安全策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E7%AE%80%E8%BF%B0kubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">49.</span> <span class="toc-text">49、简述 Kubernetes 网络模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E7%AE%80%E8%BF%B0kubernetes-cni%E6%A8%A1%E5%9E%8B"><span class="toc-number">50.</span> <span class="toc-text">50、简述 Kubernetes CNI 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E7%AE%80%E8%BF%B0kubernetes%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5"><span class="toc-number">51.</span> <span class="toc-text">51、简述 Kubernetes 网络策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E7%AE%80%E8%BF%B0kubernetes%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5%E5%8E%9F%E7%90%86"><span class="toc-number">52.</span> <span class="toc-text">52、简述 Kubernetes 网络策略原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E7%AE%80%E8%BF%B0kubernetes%E4%B8%ADflannel%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">53.</span> <span class="toc-text">53、简述 Kubernetes 中 flannel 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E7%AE%80%E8%BF%B0kubernetes-calico%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">54.</span> <span class="toc-text">54、简述 Kubernetes Calico 网络组件实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E7%AE%80%E8%BF%B0kubernetes%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">55.</span> <span class="toc-text">55、简述 Kubernetes 共享存储的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E7%AE%80%E8%BF%B0kubernetes%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">56.</span> <span class="toc-text">56、简述 Kubernetes 数据持久化的方式有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-%E7%AE%80%E8%BF%B0kubernetes-pv%E5%92%8Cpvc"><span class="toc-number">57.</span> <span class="toc-text">57、简述 Kubernetes PV 和 PVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58-%E7%AE%80%E8%BF%B0kubernetes-pv%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%86%85%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="toc-number">58.</span> <span class="toc-text">58、简述 Kubernetes PV 生命周期内的阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-%E7%AE%80%E8%BF%B0kubernetes%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84%E5%AD%98%E5%82%A8%E4%BE%9B%E5%BA%94%E6%A8%A1%E5%BC%8F"><span class="toc-number">59.</span> <span class="toc-text">59、简述 Kubernetes 所支持的存储供应模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-%E7%AE%80%E8%BF%B0kubernetes-csi%E6%A8%A1%E5%9E%8B"><span class="toc-number">60.</span> <span class="toc-text">60、简述 Kubernetes CSI 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61-%E7%AE%80%E8%BF%B0kubernetes-worker%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5%E9%9B%86%E7%BE%A4%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">61.</span> <span class="toc-text">61、简述 Kubernetes Worker 节点加入集群的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E7%AE%80%E8%BF%B0kubernetes-pod%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%8A%82%E7%82%B9%E7%9A%84%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6"><span class="toc-number">62.</span> <span class="toc-text">62、简述 Kubernetes Pod 如何实现对节点的资源控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E7%AE%80%E8%BF%B0kubernetes-requests%E5%92%8Climits%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8Dpod%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">63.</span> <span class="toc-text">63、简述 Kubernetes Requests 和 Limits 如何影响 Pod 的调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-%E7%AE%80%E8%BF%B0kubernetes-metric-service"><span class="toc-number">64.</span> <span class="toc-text">64、简述 Kubernetes Metric Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65-%E7%AE%80%E8%BF%B0kubernetes%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8efk%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E7%9A%84%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86"><span class="toc-number">65.</span> <span class="toc-text">65、简述 Kubernetes 中，如何使用 EFK 实现日志的统一管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66-%E7%AE%80%E8%BF%B0kubernetes%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%BC%98%E9%9B%85%E7%9A%84%E8%8A%82%E7%82%B9%E5%85%B3%E6%9C%BA%E7%BB%B4%E6%8A%A4"><span class="toc-number">66.</span> <span class="toc-text">66、简述 Kubernetes 如何进行优雅的节点关机维护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67-%E7%AE%80%E8%BF%B0kubernetes%E9%9B%86%E7%BE%A4%E8%81%94%E9%82%A6"><span class="toc-number">67.</span> <span class="toc-text">67、简述 Kubernetes 集群联邦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68-%E7%AE%80%E8%BF%B0helm%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8A%BF"><span class="toc-number">68.</span> <span class="toc-text">68、简述 Helm 及其优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69-k8s%E6%98%AF%E4%BB%80%E4%B9%88%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%BD%A0%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">69.</span> <span class="toc-text">69、k8s 是什么？请说出你的了解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-k8s%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BB%84%E6%88%90%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">70.</span> <span class="toc-text">70、K8s 架构的组成是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#k8s%E6%9E%B6%E6%9E%84%E7%BB%86%E5%88%86"><span class="toc-number">70.1.</span> <span class="toc-text">K8S 架构细分：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71-%E5%AE%B9%E5%99%A8%E5%92%8C%E4%B8%BB%E6%9C%BA%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">71.</span> <span class="toc-text">71、容器和主机部署应用的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E4%B8%8Bkubenetes%E9%92%88%E5%AF%B9pod%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%81%A5%E5%BA%B7%E7%9B%91%E6%B5%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">72.</span> <span class="toc-text">72、请你说一下 kubenetes 针对 pod 资源对象的健康监测机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">73.</span> <span class="toc-text">73、如何控制滚动更新过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-k8s%E4%B8%AD%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%8B%E8%BD%BD%E7%AD%96%E7%95%A5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">74.</span> <span class="toc-text">74、K8s 中镜像的下载策略是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75-image%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">75.</span> <span class="toc-text">75、image 的状态有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76-pod%E7%9A%84%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">76.</span> <span class="toc-text">76、pod 的重启策略是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-service%E8%BF%99%E7%A7%8D%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">77.</span> <span class="toc-text">77、Service 这种资源对象的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-%E7%89%88%E6%9C%AC%E5%9B%9E%E6%BB%9A%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">78.</span> <span class="toc-text">78、版本回滚相关的命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79-%E6%A0%87%E7%AD%BE%E4%B8%8E%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">79.</span> <span class="toc-text">79、标签与标签选择器的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">80.</span> <span class="toc-text">80、常用的标签分类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#81-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%9F%A5%E7%9C%8B%E6%A0%87%E7%AD%BE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">81.</span> <span class="toc-text">81、有几种查看标签的方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82-%E6%B7%BB%E5%8A%A0-%E4%BF%AE%E6%94%B9-%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BE%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">82.</span> <span class="toc-text">82、添加、修改、删除标签的命令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83-daemonset%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">83.</span> <span class="toc-text">83、DaemonSet 资源对象的特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9job%E8%BF%99%E7%A7%8D%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">84.</span> <span class="toc-text">84、说说你对 Job 这种资源对象的了解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#85-%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8Bpod%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81"><span class="toc-number">85.</span> <span class="toc-text">85、描述一下 pod 的生命周期有哪些状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#86-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AApod%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">86.</span> <span class="toc-text">86、创建一个 pod 的流程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#87-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AApod%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85"><span class="toc-number">87.</span> <span class="toc-text">87、删除一个 Pod 会发生什么事情？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#88-k8s%E7%9A%84service%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">88.</span> <span class="toc-text">88、K8s 的 Service 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#89-k8s%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E7%9A%84"><span class="toc-number">89.</span> <span class="toc-text">89、k8s 是怎么进行服务注册的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90-k8s%E9%9B%86%E7%BE%A4%E5%A4%96%E6%B5%81%E9%87%8F%E6%80%8E%E4%B9%88%E8%AE%BF%E9%97%AEpod"><span class="toc-number">90.</span> <span class="toc-text">90、k8s 集群外流量怎么访问 Pod？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#91-k8s%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">91.</span> <span class="toc-text">91、k8s 数据持久化的方式有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1emptydir%E7%A9%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">91.1.</span> <span class="toc-text">1）EmptyDir（空目录）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2hostpath"><span class="toc-number">91.2.</span> <span class="toc-text">2）Hostpath：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3persistentvolume%E7%AE%80%E7%A7%B0pv"><span class="toc-number">91.3.</span> <span class="toc-text">3）PersistentVolume（简称 PV）：</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="CIBao" data-src="/images/avatar.jpeg"><p class="name" itemprop="name">CIBao</p><div class="description" itemprop="description">又菜又爱浪</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">76</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NpYmFv" title="https:&#x2F;&#x2F;github.com&#x2F;cibao"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/08/20/leetcode/Leetcode2816/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/08/21/article/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">CIBao @ CIBao</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">87k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:19</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/08/20/cs/91道常见的Kubernetes面试题总结/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->